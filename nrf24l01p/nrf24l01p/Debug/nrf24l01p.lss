
nrf24l01p.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000070  00800100  00000ba4  00000c38  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ba4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000027  00800170  00800170  00000ca8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ca8  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002f0  00000000  00000000  00000cd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000599b  00000000  00000000  00000fc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000009a2  00000000  00000000  00006963  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000ceb  00000000  00000000  00007305  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000adc  00000000  00000000  00007ff0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000136a  00000000  00000000  00008acc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003d20  00000000  00000000  00009e36  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002d8  00000000  00000000  0000db56  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
   8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
   c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  30:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  40:	0c 94 10 01 	jmp	0x220	; 0x220 <__vector_16>
  44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  48:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	11 12       	cpse	r1, r17
  6a:	13 14       	cp	r1, r3
  6c:	15 16       	cp	r1, r21

0000006e <_ZL10child_pipe>:
  6e:	0a 0b 0c 0d 0e 0f                                   ......

00000074 <_ZL17child_pipe_enable>:
  74:	00 01 02 03 04 05                                   ......

0000007a <__ctors_start>:
  7a:	0b 01       	movw	r0, r22

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e4 ea       	ldi	r30, 0xA4	; 164
  90:	fb e0       	ldi	r31, 0x0B	; 11
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a0 37       	cpi	r26, 0x70	; 112
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	21 e0       	ldi	r18, 0x01	; 1
  a0:	a0 e7       	ldi	r26, 0x70	; 112
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a7 39       	cpi	r26, 0x97	; 151
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>

000000ae <__do_global_ctors>:
  ae:	10 e0       	ldi	r17, 0x00	; 0
  b0:	cc e7       	ldi	r28, 0x7C	; 124
  b2:	d0 e0       	ldi	r29, 0x00	; 0
  b4:	04 c0       	rjmp	.+8      	; 0xbe <__do_global_ctors+0x10>
  b6:	22 97       	sbiw	r28, 0x02	; 2
  b8:	fe 01       	movw	r30, r28
  ba:	0e 94 01 04 	call	0x802	; 0x802 <__tablejump__>
  be:	ca 37       	cpi	r28, 0x7A	; 122
  c0:	d1 07       	cpc	r29, r17
  c2:	c9 f7       	brne	.-14     	; 0xb6 <__do_global_ctors+0x8>
  c4:	0e 94 b3 00 	call	0x166	; 0x166 <main>
  c8:	0c 94 d0 05 	jmp	0xba0	; 0xba0 <_exit>

000000cc <__bad_interrupt>:
  cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <_Z23usart_transmit_byte_valh>:
/**
 * transmit byte via pass by value
 * @param data data byte to be sent
 */
void usart_transmit_byte_val(uint8_t data){
	 while (!(UCSR0A & (1<<UDRE0)));
  d0:	e0 ec       	ldi	r30, 0xC0	; 192
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	90 81       	ld	r25, Z
  d6:	95 ff       	sbrs	r25, 5
  d8:	fd cf       	rjmp	.-6      	; 0xd4 <_Z23usart_transmit_byte_valh+0x4>
	 UDR0 = data;
  da:	80 93 c6 00 	sts	0x00C6, r24
  de:	08 95       	ret

000000e0 <_Z12uart_putcharcP6__file>:

/**
 * putchar for streaming file out
 */
int uart_putchar(char ch, FILE *stream)
{
  e0:	cf 93       	push	r28
  e2:	c8 2f       	mov	r28, r24
	if(ch=='\n')
  e4:	8a 30       	cpi	r24, 0x0A	; 10
  e6:	19 f4       	brne	.+6      	; 0xee <_Z12uart_putcharcP6__file+0xe>
	uart_putchar('\r',stream);
  e8:	8d e0       	ldi	r24, 0x0D	; 13
  ea:	0e 94 70 00 	call	0xe0	; 0xe0 <_Z12uart_putcharcP6__file>
	stdio_serial_send_function((uint8_t) ch);
  ee:	8c 2f       	mov	r24, r28
  f0:	0e 94 68 00 	call	0xd0	; 0xd0 <_Z23usart_transmit_byte_valh>
	return 0;
}
  f4:	80 e0       	ldi	r24, 0x00	; 0
  f6:	90 e0       	ldi	r25, 0x00	; 0
  f8:	cf 91       	pop	r28
  fa:	08 95       	ret

000000fc <_Z22usart_receive_byte_refPh>:
/**
 * receive byte via reference
 * @param data address of data byte into which the data shall be recieved
 */
void usart_receive_byte_ref(uint8_t *data){
	 while (!(UCSR0A & (1<<RXC0)));
  fc:	e0 ec       	ldi	r30, 0xC0	; 192
  fe:	f0 e0       	ldi	r31, 0x00	; 0
 100:	20 81       	ld	r18, Z
 102:	22 23       	and	r18, r18
 104:	ec f7       	brge	.-6      	; 0x100 <_Z22usart_receive_byte_refPh+0x4>
	 *data = UDR0;
 106:	20 91 c6 00 	lds	r18, 0x00C6
 10a:	fc 01       	movw	r30, r24
 10c:	20 83       	st	Z, r18
 10e:	08 95       	ret

00000110 <_Z12uart_getcharP6__file>:
/**
 * get char for streaming file in
 */
int uart_getchar(FILE *stream)
{
 110:	0f 93       	push	r16
 112:	1f 93       	push	r17
 114:	cf 93       	push	r28
 116:	df 93       	push	r29
 118:	1f 92       	push	r1
 11a:	cd b7       	in	r28, 0x3d	; 61
 11c:	de b7       	in	r29, 0x3e	; 62
 11e:	8c 01       	movw	r16, r24
	char ch;
	stdio_serial_receive_function( (uint8_t *) &ch);
 120:	ce 01       	movw	r24, r28
 122:	01 96       	adiw	r24, 0x01	; 1
 124:	0e 94 7e 00 	call	0xfc	; 0xfc <_Z22usart_receive_byte_refPh>
	
	/* Echo the output back to the terminal */
	uart_putchar(ch,stream);
 128:	b8 01       	movw	r22, r16
 12a:	89 81       	ldd	r24, Y+1	; 0x01
 12c:	0e 94 70 00 	call	0xe0	; 0xe0 <_Z12uart_putcharcP6__file>

	return ch;
 130:	89 81       	ldd	r24, Y+1	; 0x01
}
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	0f 90       	pop	r0
 136:	df 91       	pop	r29
 138:	cf 91       	pop	r28
 13a:	1f 91       	pop	r17
 13c:	0f 91       	pop	r16
 13e:	08 95       	ret

00000140 <_Z23stdio_serial_initializev>:
/**
 * initializing the stdio file stream over uart
 */
void stdio_serial_initialize()
{
	uart_str = fdevopen(uart_putchar,uart_getchar);	
 140:	68 e8       	ldi	r22, 0x88	; 136
 142:	70 e0       	ldi	r23, 0x00	; 0
 144:	80 e7       	ldi	r24, 0x70	; 112
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	0e 94 0e 04 	call	0x81c	; 0x81c <fdevopen>
 14c:	90 93 82 01 	sts	0x0182, r25
 150:	80 93 81 01 	sts	0x0181, r24
	stdout = stdin = uart_str;
 154:	90 93 8e 01 	sts	0x018E, r25
 158:	80 93 8d 01 	sts	0x018D, r24
 15c:	90 93 90 01 	sts	0x0190, r25
 160:	80 93 8f 01 	sts	0x018F, r24
 164:	08 95       	ret

00000166 <main>:
 * initialize the usart baud rate
 * @param baud_rate the baud rate for teh usart module
 */
void usart_set_baud_rate(unsigned long baud_rate){
	unsigned int ubrr = (F_CPU/16/baud_rate)-1;
	UBRR0H = (unsigned char)(ubrr>>8);
 166:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr;
 16a:	83 e3       	ldi	r24, 0x33	; 51
 16c:	80 93 c4 00 	sts	0x00C4, r24
 * @param stop_bits	0->1 stop bit, 1-> 2 stop bits
 * @param char_size	0->5-bit, 1->6-bit, 2->7-bit, 3->8-bit,7->9-bit
 * @param pol		0->tx or rising, rx on falling, 1-> tx on falling, rx on rising
 */
void usart_setup(uint8_t mode, uint8_t parity, uint8_t stop_bits, uint8_t char_size,uint8_t pol){
	 UCSR0C =  (mode<<6) | (parity<<4) | (stop_bits<<3) |(char_size<<1) | (pol<<0);
 170:	86 e0       	ldi	r24, 0x06	; 6
 172:	80 93 c2 00 	sts	0x00C2, r24

/**
 * enable the USART tx and rx
 */
void usart_enable(){
	 UCSR0B = (1<<RXEN0)|(1<<TXEN0);
 176:	88 e1       	ldi	r24, 0x18	; 24
 178:	80 93 c1 00 	sts	0x00C1, r24

	//UART
	usart_set_baud_rate(9600);
	usart_setup(0,0,0,3,0);
	usart_enable();
	stdio_serial_initialize();
 17c:	0e 94 a0 00 	call	0x140	; 0x140 <_Z23stdio_serial_initializev>
	
	printf("RF24/examples/GettingStarted\n");
 180:	8d e1       	ldi	r24, 0x1D	; 29
 182:	91 e0       	ldi	r25, 0x01	; 1
 184:	0e 94 59 04 	call	0x8b2	; 0x8b2 <puts>
	printf("*** PRESS 'T' to begin transmitting to the other node\n");
 188:	8a e3       	ldi	r24, 0x3A	; 58
 18a:	91 e0       	ldi	r25, 0x01	; 1
 18c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <puts>
	return elapsed_us;
	//return 0;
}

inline void initialize_timer_0A(){
	TCCR0A |= (1<<WGM01) | (1<<WGM00); //fast pwm
 190:	84 b5       	in	r24, 0x24	; 36
 192:	83 60       	ori	r24, 0x03	; 3
 194:	84 bd       	out	0x24, r24	; 36
	//TCCR0B |= (1<<FOC0A) ;//force output compare match on channel A
	TCCR0B |= (1<<CS01) | (1<<CS00); // div by 64 , therefore , if 8MHz --> 1Mhz ....if 16 MHz --> 2 MHz
 196:	85 b5       	in	r24, 0x25	; 37
 198:	83 60       	ori	r24, 0x03	; 3
 19a:	85 bd       	out	0x25, r24	; 37
	
	//OCR0A = 4; //if 8 Mhz return 10 us on compare,  if 16 Mhz return 5 us on compare
	TIMSK0 |= (1<<TOIE0);
 19c:	ee e6       	ldi	r30, 0x6E	; 110
 19e:	f0 e0       	ldi	r31, 0x00	; 0
 1a0:	80 81       	ld	r24, Z
 1a2:	81 60       	ori	r24, 0x01	; 1
 1a4:	80 83       	st	Z, r24
	sei();
 1a6:	78 94       	sei

	initialize_timer_0A();

    radio.begin();
 1a8:	80 e7       	ldi	r24, 0x70	; 112
 1aa:	91 e0       	ldi	r25, 0x01	; 1
 1ac:	0e 94 a6 03 	call	0x74c	; 0x74c <_ZN4RF245beginEv>
	//radio.setDataRate(RF24_250KBPS);
	radio.setPALevel(RF24_PA_LOW);
 1b0:	61 e0       	ldi	r22, 0x01	; 1
 1b2:	80 e7       	ldi	r24, 0x70	; 112
 1b4:	91 e0       	ldi	r25, 0x01	; 1
 1b6:	0e 94 4c 03 	call	0x698	; 0x698 <_ZN4RF2410setPALevelEh>
	
  // Open a writing and reading pipe on each radio, with opposite addresses
	if(radioNumber) {
 1ba:	80 91 80 01 	lds	r24, 0x0180
 1be:	88 23       	and	r24, r24
 1c0:	71 f0       	breq	.+28     	; 0x1de <main+0x78>
		radio.openWritingPipe(addresses[1]);
 1c2:	6c e0       	ldi	r22, 0x0C	; 12
 1c4:	71 e0       	ldi	r23, 0x01	; 1
 1c6:	80 e7       	ldi	r24, 0x70	; 112
 1c8:	91 e0       	ldi	r25, 0x01	; 1
 1ca:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <_ZN4RF2415openWritingPipeEPKh>
		radio.openReadingPipe(1,addresses[0]);
 1ce:	46 e0       	ldi	r20, 0x06	; 6
 1d0:	51 e0       	ldi	r21, 0x01	; 1
 1d2:	61 e0       	ldi	r22, 0x01	; 1
 1d4:	80 e7       	ldi	r24, 0x70	; 112
 1d6:	91 e0       	ldi	r25, 0x01	; 1
 1d8:	0e 94 85 02 	call	0x50a	; 0x50a <_ZN4RF2415openReadingPipeEhPKh>
 1dc:	0d c0       	rjmp	.+26     	; 0x1f8 <main+0x92>
	}
	else {
		radio.openWritingPipe(addresses[0]);
 1de:	66 e0       	ldi	r22, 0x06	; 6
 1e0:	71 e0       	ldi	r23, 0x01	; 1
 1e2:	80 e7       	ldi	r24, 0x70	; 112
 1e4:	91 e0       	ldi	r25, 0x01	; 1
 1e6:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <_ZN4RF2415openWritingPipeEPKh>
		radio.openReadingPipe(1,addresses[1]);
 1ea:	4c e0       	ldi	r20, 0x0C	; 12
 1ec:	51 e0       	ldi	r21, 0x01	; 1
 1ee:	61 e0       	ldi	r22, 0x01	; 1
 1f0:	80 e7       	ldi	r24, 0x70	; 112
 1f2:	91 e0       	ldi	r25, 0x01	; 1
 1f4:	0e 94 85 02 	call	0x50a	; 0x50a <_ZN4RF2415openReadingPipeEhPKh>
	}
    
    radio.startListening();
 1f8:	80 e7       	ldi	r24, 0x70	; 112
 1fa:	91 e0       	ldi	r25, 0x01	; 1
 1fc:	0e 94 f7 02 	call	0x5ee	; 0x5ee <_ZN4RF2414startListeningEv>
// 				radio.startListening();
// 				
// 			}
// 		}

		radio.ce(false);
 200:	60 e0       	ldi	r22, 0x00	; 0
 202:	80 e7       	ldi	r24, 0x70	; 112
 204:	91 e0       	ldi	r25, 0x01	; 1
 206:	0e 94 84 01 	call	0x308	; 0x308 <_ZN4RF242ceEb>
		//_delay_ms(1000);
		radio.ce(true);
 20a:	61 e0       	ldi	r22, 0x01	; 1
 20c:	80 e7       	ldi	r24, 0x70	; 112
 20e:	91 e0       	ldi	r25, 0x01	; 1
 210:	0e 94 84 01 	call	0x308	; 0x308 <_ZN4RF242ceEb>
 214:	f5 cf       	rjmp	.-22     	; 0x200 <main+0x9a>

00000216 <_GLOBAL__sub_I__Z19usart_set_baud_ratem>:
/****************** User Config ***************************/
/***      Set this radio as radio number 0 or 1         ***/
bool radioNumber = 0;

/* Hardware configuration: Set up nRF24L01 radio on SPI bus plus pins 7 & 8 */
RF24 radio;
 216:	80 e7       	ldi	r24, 0x70	; 112
 218:	91 e0       	ldi	r25, 0x01	; 1
 21a:	0e 94 3e 02 	call	0x47c	; 0x47c <_ZN4RF24C1Ev>
 21e:	08 95       	ret

00000220 <__vector_16>:
volatile int us_counter = 0;
volatile int ms_counter = 0;
volatile int elapsed_us = 0;
volatile int elapsed_ms = 0;

ISR (TIMER0_OVF_vect){
 220:	1f 92       	push	r1
 222:	0f 92       	push	r0
 224:	0f b6       	in	r0, 0x3f	; 63
 226:	0f 92       	push	r0
 228:	11 24       	eor	r1, r1
 22a:	2f 93       	push	r18
 22c:	8f 93       	push	r24
 22e:	9f 93       	push	r25
	us_4++;
 230:	80 91 8b 01 	lds	r24, 0x018B
 234:	90 91 8c 01 	lds	r25, 0x018C
 238:	01 96       	adiw	r24, 0x01	; 1
 23a:	90 93 8c 01 	sts	0x018C, r25
 23e:	80 93 8b 01 	sts	0x018B, r24
	if(us_4>=250){  ////if 8 Mhz make it >100 ,  if 16 Mhz   make it  > 200
 242:	80 91 8b 01 	lds	r24, 0x018B
 246:	90 91 8c 01 	lds	r25, 0x018C
 24a:	8a 3f       	cpi	r24, 0xFA	; 250
 24c:	91 05       	cpc	r25, r1
 24e:	0c f4       	brge	.+2      	; 0x252 <__vector_16+0x32>
 250:	43 c0       	rjmp	.+134    	; 0x2d8 <__vector_16+0xb8>
		us_4 = 0;
 252:	10 92 8c 01 	sts	0x018C, r1
 256:	10 92 8b 01 	sts	0x018B, r1
		us_counter++;
 25a:	80 91 89 01 	lds	r24, 0x0189
 25e:	90 91 8a 01 	lds	r25, 0x018A
 262:	01 96       	adiw	r24, 0x01	; 1
 264:	90 93 8a 01 	sts	0x018A, r25
 268:	80 93 89 01 	sts	0x0189, r24
		elapsed_us ++;  //increment the us
 26c:	80 91 85 01 	lds	r24, 0x0185
 270:	90 91 86 01 	lds	r25, 0x0186
 274:	01 96       	adiw	r24, 0x01	; 1
 276:	90 93 86 01 	sts	0x0186, r25
 27a:	80 93 85 01 	sts	0x0185, r24
		if(us_counter>1000){
 27e:	80 91 89 01 	lds	r24, 0x0189
 282:	90 91 8a 01 	lds	r25, 0x018A
 286:	89 3e       	cpi	r24, 0xE9	; 233
 288:	93 40       	sbci	r25, 0x03	; 3
 28a:	2c f1       	brlt	.+74     	; 0x2d6 <__vector_16+0xb6>
			us_counter=0;
 28c:	10 92 8a 01 	sts	0x018A, r1
 290:	10 92 89 01 	sts	0x0189, r1
			elapsed_ms++; //increment the ms
 294:	80 91 83 01 	lds	r24, 0x0183
 298:	90 91 84 01 	lds	r25, 0x0184
 29c:	01 96       	adiw	r24, 0x01	; 1
 29e:	90 93 84 01 	sts	0x0184, r25
 2a2:	80 93 83 01 	sts	0x0183, r24
			ms_counter++;
 2a6:	80 91 87 01 	lds	r24, 0x0187
 2aa:	90 91 88 01 	lds	r25, 0x0188
 2ae:	01 96       	adiw	r24, 0x01	; 1
 2b0:	90 93 88 01 	sts	0x0188, r25
 2b4:	80 93 87 01 	sts	0x0187, r24
			if(ms_counter>=1000)
 2b8:	80 91 87 01 	lds	r24, 0x0187
 2bc:	90 91 88 01 	lds	r25, 0x0188
 2c0:	88 3e       	cpi	r24, 0xE8	; 232
 2c2:	93 40       	sbci	r25, 0x03	; 3
 2c4:	44 f0       	brlt	.+16     	; 0x2d6 <__vector_16+0xb6>
			{
				ms_counter = 0;
 2c6:	10 92 88 01 	sts	0x0188, r1
 2ca:	10 92 87 01 	sts	0x0187, r1
				PORTB^=1;
 2ce:	95 b1       	in	r25, 0x05	; 5
 2d0:	81 e0       	ldi	r24, 0x01	; 1
 2d2:	89 27       	eor	r24, r25
 2d4:	85 b9       	out	0x05, r24	; 5
			}
		}
		asm("nop");
 2d6:	00 00       	nop
	}
 2d8:	9f 91       	pop	r25
 2da:	8f 91       	pop	r24
 2dc:	2f 91       	pop	r18
 2de:	0f 90       	pop	r0
 2e0:	0f be       	out	0x3f, r0	; 63
 2e2:	0f 90       	pop	r0
 2e4:	1f 90       	pop	r1
 2e6:	18 95       	reti

000002e8 <_ZN4RF243csnEb>:
	  _SPI.setDataMode(RF24_DATA_MODE);
	  _SPI.setClockDivider(spi_speed ? spi_speed : RF24_CLOCK_DIVIDER);
	  _SPI.chipSelect(csn_pin);
	  delayMicroseconds(5);
#elif defined (__AVR__) 
	  if (mode == HIGH) {
 2e8:	66 23       	and	r22, r22
 2ea:	41 f0       	breq	.+16     	; 0x2fc <_ZN4RF243csnEb+0x14>
		  CSN_PORT |= (1<<CSN_BIT);  	// SCK->CSN HIGH
 2ec:	28 9a       	sbi	0x05, 0	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2ee:	87 ec       	ldi	r24, 0xC7	; 199
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	01 97       	sbiw	r24, 0x01	; 1
 2f4:	f1 f7       	brne	.-4      	; 0x2f2 <_ZN4RF243csnEb+0xa>
 2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <_ZN4RF243csnEb+0x10>
 2f8:	00 00       	nop
 2fa:	08 95       	ret
		  delayMicroseconds(100); // allow csn to settle.
	  }
	  else {
		  CSN_PORT &= ~(1<<CSN_BIT);	// SCK->CSN LOW
 2fc:	28 98       	cbi	0x05, 0	; 5
 2fe:	9d e1       	ldi	r25, 0x1D	; 29
 300:	9a 95       	dec	r25
 302:	f1 f7       	brne	.-4      	; 0x300 <_ZN4RF243csnEb+0x18>
 304:	00 00       	nop
 306:	08 95       	ret

00000308 <_ZN4RF242ceEb>:

void RF24::ce(bool level)
{
	#if defined(__AVR__)
	
		if (level == HIGH) {
 308:	66 23       	and	r22, r22
 30a:	41 f0       	breq	.+16     	; 0x31c <_ZN4RF242ceEb+0x14>
			CE_PORT |= (1<<CE_BIT);  	// SCK->CSN HIGH
 30c:	5f 9a       	sbi	0x0b, 7	; 11
 30e:	87 ec       	ldi	r24, 0xC7	; 199
 310:	90 e0       	ldi	r25, 0x00	; 0
 312:	01 97       	sbiw	r24, 0x01	; 1
 314:	f1 f7       	brne	.-4      	; 0x312 <_ZN4RF242ceEb+0xa>
 316:	00 c0       	rjmp	.+0      	; 0x318 <_ZN4RF242ceEb+0x10>
 318:	00 00       	nop
 31a:	08 95       	ret
			delayMicroseconds(100); // allow csn to settle.
		}
		else {
			CE_PORT &= ~(1<<CE_BIT);	// SCK->CSN LOW
 31c:	5f 98       	cbi	0x0b, 7	; 11
 31e:	9d e1       	ldi	r25, 0x1D	; 29
 320:	9a 95       	dec	r25
 322:	f1 f7       	brne	.-4      	; 0x320 <_ZN4RF242ceEb+0x18>
 324:	00 00       	nop
 326:	08 95       	ret

00000328 <_ZN4RF2413read_registerEh>:
}

/****************************************************************************/

uint8_t RF24::read_register(uint8_t reg)
{
 328:	1f 93       	push	r17
 32a:	cf 93       	push	r28
 32c:	df 93       	push	r29
 32e:	ec 01       	movw	r28, r24
 330:	16 2f       	mov	r17, r22
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 332:	84 b1       	in	r24, 0x04	; 4
 334:	8c 62       	ori	r24, 0x2C	; 44
 336:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 338:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 33a:	8c b5       	in	r24, 0x2c	; 44
 33c:	80 65       	ori	r24, 0x50	; 80
 33e:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 340:	60 e0       	ldi	r22, 0x00	; 0
 342:	ce 01       	movw	r24, r28
 344:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
  _SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, 2);
  result = *++prx;   // result is 2nd byte of receive buffer  

	#elif defined(__AVR__)
	beginTransaction();
	AVR_SPI_MSTR_TRANSMIT_VAL( R_REGISTER | ( REGISTER_MASK & reg ) );
 348:	1f 71       	andi	r17, 0x1F	; 31
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 34a:	1e bd       	out	0x2e, r17	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 34c:	0d b4       	in	r0, 0x2d	; 45
 34e:	07 fe       	sbrs	r0, 7
 350:	fd cf       	rjmp	.-6      	; 0x34c <_ZN4RF2413read_registerEh+0x24>
	return SPDR;
 352:	8e b5       	in	r24, 0x2e	; 46
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 354:	8f ef       	ldi	r24, 0xFF	; 255
 356:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 358:	0d b4       	in	r0, 0x2d	; 45
 35a:	07 fe       	sbrs	r0, 7
 35c:	fd cf       	rjmp	.-6      	; 0x358 <_ZN4RF2413read_registerEh+0x30>
	return SPDR;
 35e:	1e b5       	in	r17, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 360:	61 e0       	ldi	r22, 0x01	; 1
 362:	ce 01       	movw	r24, r28
 364:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return result;
}
 368:	81 2f       	mov	r24, r17
 36a:	df 91       	pop	r29
 36c:	cf 91       	pop	r28
 36e:	1f 91       	pop	r17
 370:	08 95       	ret

00000372 <_ZN4RF2414write_registerEhPKhh>:

/****************************************************************************/

uint8_t RF24::write_register(uint8_t reg, const uint8_t* buf, uint8_t len)
{
 372:	ef 92       	push	r14
 374:	ff 92       	push	r15
 376:	0f 93       	push	r16
 378:	1f 93       	push	r17
 37a:	cf 93       	push	r28
 37c:	df 93       	push	r29
 37e:	ec 01       	movw	r28, r24
 380:	06 2f       	mov	r16, r22
 382:	e4 2e       	mov	r14, r20
 384:	f5 2e       	mov	r15, r21
 386:	12 2f       	mov	r17, r18
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 388:	84 b1       	in	r24, 0x04	; 4
 38a:	8c 62       	ori	r24, 0x2C	; 44
 38c:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 38e:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 390:	8c b5       	in	r24, 0x2c	; 44
 392:	80 65       	ori	r24, 0x50	; 80
 394:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 396:	60 e0       	ldi	r22, 0x00	; 0
 398:	ce 01       	movw	r24, r28
 39a:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
  _SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, size);
  status = *prx; // status is 1st byte of receive buffer

  	#elif defined(__AVR__)
  	 beginTransaction();
  	 status = AVR_SPI_MSTR_TRANSMIT_VAL( W_REGISTER | ( REGISTER_MASK & reg ) );
 39e:	0f 71       	andi	r16, 0x1F	; 31
 3a0:	00 62       	ori	r16, 0x20	; 32
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 3a2:	0e bd       	out	0x2e, r16	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 3a4:	0d b4       	in	r0, 0x2d	; 45
 3a6:	07 fe       	sbrs	r0, 7
 3a8:	fd cf       	rjmp	.-6      	; 0x3a4 <_ZN4RF2414write_registerEhPKhh+0x32>
	return SPDR;
 3aa:	0e b5       	in	r16, 0x2e	; 46
  	 while ( len-- )
 3ac:	9f ef       	ldi	r25, 0xFF	; 255
 3ae:	91 0f       	add	r25, r17
 3b0:	11 23       	and	r17, r17
 3b2:	51 f0       	breq	.+20     	; 0x3c8 <_ZN4RF2414write_registerEhPKhh+0x56>
 3b4:	ee 2d       	mov	r30, r14
 3b6:	ff 2d       	mov	r31, r15
  	 AVR_SPI_MSTR_TRANSMIT_VAL(*buf++);
 3b8:	21 91       	ld	r18, Z+
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 3ba:	2e bd       	out	0x2e, r18	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 3bc:	0d b4       	in	r0, 0x2d	; 45
 3be:	07 fe       	sbrs	r0, 7
 3c0:	fd cf       	rjmp	.-6      	; 0x3bc <_ZN4RF2414write_registerEhPKhh+0x4a>
	return SPDR;
 3c2:	2e b5       	in	r18, 0x2e	; 46
  status = *prx; // status is 1st byte of receive buffer

  	#elif defined(__AVR__)
  	 beginTransaction();
  	 status = AVR_SPI_MSTR_TRANSMIT_VAL( W_REGISTER | ( REGISTER_MASK & reg ) );
  	 while ( len-- )
 3c4:	91 50       	subi	r25, 0x01	; 1
 3c6:	c0 f7       	brcc	.-16     	; 0x3b8 <_ZN4RF2414write_registerEhPKhh+0x46>
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 3c8:	61 e0       	ldi	r22, 0x01	; 1
 3ca:	ce 01       	movw	r24, r28
 3cc:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return status;
}
 3d0:	80 2f       	mov	r24, r16
 3d2:	df 91       	pop	r29
 3d4:	cf 91       	pop	r28
 3d6:	1f 91       	pop	r17
 3d8:	0f 91       	pop	r16
 3da:	ff 90       	pop	r15
 3dc:	ef 90       	pop	r14
 3de:	08 95       	ret

000003e0 <_ZN4RF2414write_registerEhh>:

/****************************************************************************/

uint8_t RF24::write_register(uint8_t reg, uint8_t value)
{
 3e0:	0f 93       	push	r16
 3e2:	1f 93       	push	r17
 3e4:	cf 93       	push	r28
 3e6:	df 93       	push	r29
 3e8:	ec 01       	movw	r28, r24
 3ea:	16 2f       	mov	r17, r22
 3ec:	04 2f       	mov	r16, r20
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 3ee:	84 b1       	in	r24, 0x04	; 4
 3f0:	8c 62       	ori	r24, 0x2C	; 44
 3f2:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 3f4:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 3f6:	8c b5       	in	r24, 0x2c	; 44
 3f8:	80 65       	ori	r24, 0x50	; 80
 3fa:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 3fc:	60 e0       	ldi	r22, 0x00	; 0
 3fe:	ce 01       	movw	r24, r28
 400:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
	_SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, 2);
	status = *prx++; // status is 1st byte of receive buffer

	#elif defined(__AVR__)
	beginTransaction();
	status = AVR_SPI_MSTR_TRANSMIT_VAL( W_REGISTER | ( REGISTER_MASK & reg ) );
 404:	1f 71       	andi	r17, 0x1F	; 31
 406:	10 62       	ori	r17, 0x20	; 32
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 408:	1e bd       	out	0x2e, r17	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 40a:	0d b4       	in	r0, 0x2d	; 45
 40c:	07 fe       	sbrs	r0, 7
 40e:	fd cf       	rjmp	.-6      	; 0x40a <_ZN4RF2414write_registerEhh+0x2a>
	return SPDR;
 410:	1e b5       	in	r17, 0x2e	; 46
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 412:	0e bd       	out	0x2e, r16	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 414:	0d b4       	in	r0, 0x2d	; 45
 416:	07 fe       	sbrs	r0, 7
 418:	fd cf       	rjmp	.-6      	; 0x414 <_ZN4RF2414write_registerEhh+0x34>
	return SPDR;
 41a:	8e b5       	in	r24, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 41c:	61 e0       	ldi	r22, 0x01	; 1
 41e:	ce 01       	movw	r24, r28
 420:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return status;
}
 424:	81 2f       	mov	r24, r17
 426:	df 91       	pop	r29
 428:	cf 91       	pop	r28
 42a:	1f 91       	pop	r17
 42c:	0f 91       	pop	r16
 42e:	08 95       	ret

00000430 <_ZN4RF248spiTransEh>:
  return spiTrans( FLUSH_TX );
}

/****************************************************************************/

uint8_t RF24::spiTrans(uint8_t cmd){
 430:	1f 93       	push	r17
 432:	cf 93       	push	r28
 434:	df 93       	push	r29
 436:	ec 01       	movw	r28, r24
 438:	16 2f       	mov	r17, r22
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 43a:	84 b1       	in	r24, 0x04	; 4
 43c:	8c 62       	ori	r24, 0x2C	; 44
 43e:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 440:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 442:	8c b5       	in	r24, 0x2c	; 44
 444:	80 65       	ori	r24, 0x50	; 80
 446:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 448:	60 e0       	ldi	r22, 0x00	; 0
 44a:	ce 01       	movw	r24, r28
 44c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 450:	1e bd       	out	0x2e, r17	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 452:	0d b4       	in	r0, 0x2d	; 45
 454:	07 fe       	sbrs	r0, 7
 456:	fd cf       	rjmp	.-6      	; 0x452 <_ZN4RF248spiTransEh+0x22>
	return SPDR;
 458:	1e b5       	in	r17, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 45a:	61 e0       	ldi	r22, 0x01	; 1
 45c:	ce 01       	movw	r24, r28
 45e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return status;
}
 462:	81 2f       	mov	r24, r17
 464:	df 91       	pop	r29
 466:	cf 91       	pop	r28
 468:	1f 91       	pop	r17
 46a:	08 95       	ret

0000046c <_ZN4RF248flush_rxEv>:

/****************************************************************************/

uint8_t RF24::flush_rx(void)
{
  return spiTrans( FLUSH_RX );
 46c:	62 ee       	ldi	r22, 0xE2	; 226
 46e:	0e 94 18 02 	call	0x430	; 0x430 <_ZN4RF248spiTransEh>
}
 472:	08 95       	ret

00000474 <_ZN4RF248flush_txEv>:

/****************************************************************************/

uint8_t RF24::flush_tx(void)
{
  return spiTrans( FLUSH_TX );
 474:	61 ee       	ldi	r22, 0xE1	; 225
 476:	0e 94 18 02 	call	0x430	; 0x430 <_ZN4RF248spiTransEh>
}
 47a:	08 95       	ret

0000047c <_ZN4RF24C1Ev>:
  printf_P(PSTR("\r\n"));
}
#endif
/****************************************************************************/

RF24::RF24():p_variant(false),
 47c:	fc 01       	movw	r30, r24
payload_size(32), dynamic_payloads_enabled(false), addr_width(5)
 47e:	12 82       	std	Z+2, r1	; 0x02
 480:	80 e2       	ldi	r24, 0x20	; 32
 482:	83 83       	std	Z+3, r24	; 0x03
 484:	14 82       	std	Z+4, r1	; 0x04
 486:	85 e0       	ldi	r24, 0x05	; 5
 488:	82 87       	std	Z+10, r24	; 0x0a
{
	pipe0_reading_address[0]=0;
 48a:	15 82       	std	Z+5, r1	; 0x05
 48c:	08 95       	ret

0000048e <_ZN4RF2410setChannelEh>:
#endif

/****************************************************************************/

void RF24::setChannel(uint8_t channel)
{
 48e:	46 2f       	mov	r20, r22
  const uint8_t max_channel = 127;
  write_register(RF_CH,rf24_min(channel,max_channel));
 490:	60 38       	cpi	r22, 0x80	; 128
 492:	08 f0       	brcs	.+2      	; 0x496 <_ZN4RF2410setChannelEh+0x8>
 494:	4f e7       	ldi	r20, 0x7F	; 127
 496:	65 e0       	ldi	r22, 0x05	; 5
 498:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
 49c:	08 95       	ret

0000049e <_ZN4RF247powerUpEv>:

/****************************************************************************/

//Power up now. Radio will not power down unless instructed by MCU for config changes etc.
void RF24::powerUp(void)
{
 49e:	cf 93       	push	r28
 4a0:	df 93       	push	r29
 4a2:	ec 01       	movw	r28, r24
   uint8_t cfg = read_register(CONFIG);
 4a4:	60 e0       	ldi	r22, 0x00	; 0
 4a6:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>

   // if not powered up then power up and wait for the radio to initialize
   if (!(cfg & _BV(PWR_UP))){
 4aa:	81 fd       	sbrc	r24, 1
 4ac:	10 c0       	rjmp	.+32     	; 0x4ce <_ZN4RF247powerUpEv+0x30>
      write_register(CONFIG,read_register(CONFIG) | _BV(PWR_UP));
 4ae:	60 e0       	ldi	r22, 0x00	; 0
 4b0:	ce 01       	movw	r24, r28
 4b2:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 4b6:	48 2f       	mov	r20, r24
 4b8:	42 60       	ori	r20, 0x02	; 2
 4ba:	60 e0       	ldi	r22, 0x00	; 0
 4bc:	ce 01       	movw	r24, r28
 4be:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4c2:	8f e0       	ldi	r24, 0x0F	; 15
 4c4:	97 e2       	ldi	r25, 0x27	; 39
 4c6:	01 97       	sbiw	r24, 0x01	; 1
 4c8:	f1 f7       	brne	.-4      	; 0x4c6 <_ZN4RF247powerUpEv+0x28>
 4ca:	00 c0       	rjmp	.+0      	; 0x4cc <_ZN4RF247powerUpEv+0x2e>
 4cc:	00 00       	nop
	  _delay_ms(5);
	  #else
      delay(5);
	  #endif
   }
}
 4ce:	df 91       	pop	r29
 4d0:	cf 91       	pop	r28
 4d2:	08 95       	ret

000004d4 <_ZN4RF2415openWritingPipeEPKh>:
  write_register(RX_PW_P0,payload_size);
}

/****************************************************************************/
void RF24::openWritingPipe(const uint8_t *address)
{
 4d4:	0f 93       	push	r16
 4d6:	1f 93       	push	r17
 4d8:	cf 93       	push	r28
 4da:	df 93       	push	r29
 4dc:	ec 01       	movw	r28, r24
 4de:	8b 01       	movw	r16, r22
  // Note that AVR 8-bit uC's store this LSB first, and the NRF24L01(+)
  // expects it LSB first too, so we're good.

  write_register(RX_ADDR_P0,address, addr_width);
 4e0:	2a 85       	ldd	r18, Y+10	; 0x0a
 4e2:	ab 01       	movw	r20, r22
 4e4:	6a e0       	ldi	r22, 0x0A	; 10
 4e6:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN4RF2414write_registerEhPKhh>
  write_register(TX_ADDR, address, addr_width);
 4ea:	2a 85       	ldd	r18, Y+10	; 0x0a
 4ec:	a8 01       	movw	r20, r16
 4ee:	60 e1       	ldi	r22, 0x10	; 16
 4f0:	ce 01       	movw	r24, r28
 4f2:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN4RF2414write_registerEhPKhh>

  //const uint8_t max_payload_size = 32;
  //write_register(RX_PW_P0,rf24_min(payload_size,max_payload_size));
  write_register(RX_PW_P0,payload_size);
 4f6:	4b 81       	ldd	r20, Y+3	; 0x03
 4f8:	61 e1       	ldi	r22, 0x11	; 17
 4fa:	ce 01       	movw	r24, r28
 4fc:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
}
 500:	df 91       	pop	r29
 502:	cf 91       	pop	r28
 504:	1f 91       	pop	r17
 506:	0f 91       	pop	r16
 508:	08 95       	ret

0000050a <_ZN4RF2415openReadingPipeEhPKh>:
}

/****************************************************************************/

void RF24::openReadingPipe(uint8_t child, const uint8_t *address)
{
 50a:	ff 92       	push	r15
 50c:	0f 93       	push	r16
 50e:	1f 93       	push	r17
 510:	cf 93       	push	r28
 512:	df 93       	push	r29
 514:	ec 01       	movw	r28, r24
 516:	f6 2e       	mov	r15, r22
 518:	8a 01       	movw	r16, r20
  // If this is pipe 0, cache the address.  This is needed because
  // openWritingPipe() will overwrite the pipe 0 address, so
  // startListening() will have to restore it.
  if (child == 0){
 51a:	61 11       	cpse	r22, r1
 51c:	07 c0       	rjmp	.+14     	; 0x52c <_ZN4RF2415openReadingPipeEhPKh+0x22>
    memcpy(pipe0_reading_address,address,addr_width);
 51e:	4a 85       	ldd	r20, Y+10	; 0x0a
 520:	50 e0       	ldi	r21, 0x00	; 0
 522:	b8 01       	movw	r22, r16
 524:	05 96       	adiw	r24, 0x05	; 5
 526:	0e 94 05 04 	call	0x80a	; 0x80a <memcpy>
 52a:	07 c0       	rjmp	.+14     	; 0x53a <_ZN4RF2415openReadingPipeEhPKh+0x30>
  }
  if (child <= 6)
 52c:	66 e0       	ldi	r22, 0x06	; 6
 52e:	6f 15       	cp	r22, r15
 530:	08 f4       	brcc	.+2      	; 0x534 <_ZN4RF2415openReadingPipeEhPKh+0x2a>
 532:	36 c0       	rjmp	.+108    	; 0x5a0 <_ZN4RF2415openReadingPipeEhPKh+0x96>
  {
    // For pipes 2-5, only write the LSB
    if ( child < 2 ){
 534:	71 e0       	ldi	r23, 0x01	; 1
 536:	7f 15       	cp	r23, r15
 538:	58 f0       	brcs	.+22     	; 0x550 <_ZN4RF2415openReadingPipeEhPKh+0x46>
      write_register(pgm_read_byte(&child_pipe[child]), address, addr_width);
 53a:	ef 2d       	mov	r30, r15
 53c:	f0 e0       	ldi	r31, 0x00	; 0
 53e:	e2 59       	subi	r30, 0x92	; 146
 540:	ff 4f       	sbci	r31, 0xFF	; 255
 542:	64 91       	lpm	r22, Z
 544:	2a 85       	ldd	r18, Y+10	; 0x0a
 546:	a8 01       	movw	r20, r16
 548:	ce 01       	movw	r24, r28
 54a:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN4RF2414write_registerEhPKhh>
 54e:	08 c0       	rjmp	.+16     	; 0x560 <_ZN4RF2415openReadingPipeEhPKh+0x56>
    }else{
      write_register(pgm_read_byte(&child_pipe[child]), address, 1);
 550:	ef 2d       	mov	r30, r15
 552:	f0 e0       	ldi	r31, 0x00	; 0
 554:	e2 59       	subi	r30, 0x92	; 146
 556:	ff 4f       	sbci	r31, 0xFF	; 255
 558:	64 91       	lpm	r22, Z
 55a:	21 e0       	ldi	r18, 0x01	; 1
 55c:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN4RF2414write_registerEhPKhh>
	}
    write_register(pgm_read_byte(&child_payload_size[child]),payload_size);
 560:	0f 2d       	mov	r16, r15
 562:	10 e0       	ldi	r17, 0x00	; 0
 564:	f8 01       	movw	r30, r16
 566:	e8 59       	subi	r30, 0x98	; 152
 568:	ff 4f       	sbci	r31, 0xFF	; 255
 56a:	64 91       	lpm	r22, Z
 56c:	4b 81       	ldd	r20, Y+3	; 0x03
 56e:	ce 01       	movw	r24, r28
 570:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>

    // Note it would be more efficient to set all of the bits for all open
    // pipes at once.  However, I thought it would make the calling code
    // more simple to do it this way.
    write_register(EN_RXADDR,read_register(EN_RXADDR) | _BV(pgm_read_byte(&child_pipe_enable[child])));
 574:	62 e0       	ldi	r22, 0x02	; 2
 576:	ce 01       	movw	r24, r28
 578:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 57c:	f8 01       	movw	r30, r16
 57e:	ec 58       	subi	r30, 0x8C	; 140
 580:	ff 4f       	sbci	r31, 0xFF	; 255
 582:	44 91       	lpm	r20, Z
 584:	21 e0       	ldi	r18, 0x01	; 1
 586:	30 e0       	ldi	r19, 0x00	; 0
 588:	b9 01       	movw	r22, r18
 58a:	02 c0       	rjmp	.+4      	; 0x590 <_ZN4RF2415openReadingPipeEhPKh+0x86>
 58c:	66 0f       	add	r22, r22
 58e:	77 1f       	adc	r23, r23
 590:	4a 95       	dec	r20
 592:	e2 f7       	brpl	.-8      	; 0x58c <_ZN4RF2415openReadingPipeEhPKh+0x82>
 594:	ab 01       	movw	r20, r22
 596:	48 2b       	or	r20, r24
 598:	62 e0       	ldi	r22, 0x02	; 2
 59a:	ce 01       	movw	r24, r28
 59c:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>

  }
}
 5a0:	df 91       	pop	r29
 5a2:	cf 91       	pop	r28
 5a4:	1f 91       	pop	r17
 5a6:	0f 91       	pop	r16
 5a8:	ff 90       	pop	r15
 5aa:	08 95       	ret

000005ac <_ZN4RF2416closeReadingPipeEh>:

/****************************************************************************/

void RF24::closeReadingPipe( uint8_t pipe )
{
 5ac:	1f 93       	push	r17
 5ae:	cf 93       	push	r28
 5b0:	df 93       	push	r29
 5b2:	ec 01       	movw	r28, r24
 5b4:	16 2f       	mov	r17, r22
  write_register(EN_RXADDR,read_register(EN_RXADDR) & ~_BV(pgm_read_byte(&child_pipe_enable[pipe])));
 5b6:	62 e0       	ldi	r22, 0x02	; 2
 5b8:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 5bc:	e1 2f       	mov	r30, r17
 5be:	f0 e0       	ldi	r31, 0x00	; 0
 5c0:	ec 58       	subi	r30, 0x8C	; 140
 5c2:	ff 4f       	sbci	r31, 0xFF	; 255
 5c4:	e4 91       	lpm	r30, Z
 5c6:	21 e0       	ldi	r18, 0x01	; 1
 5c8:	30 e0       	ldi	r19, 0x00	; 0
 5ca:	a9 01       	movw	r20, r18
 5cc:	02 c0       	rjmp	.+4      	; 0x5d2 <_ZN4RF2416closeReadingPipeEh+0x26>
 5ce:	44 0f       	add	r20, r20
 5d0:	55 1f       	adc	r21, r21
 5d2:	ea 95       	dec	r30
 5d4:	e2 f7       	brpl	.-8      	; 0x5ce <_ZN4RF2416closeReadingPipeEh+0x22>
 5d6:	fa 01       	movw	r30, r20
 5d8:	e0 95       	com	r30
 5da:	4e 2f       	mov	r20, r30
 5dc:	48 23       	and	r20, r24
 5de:	62 e0       	ldi	r22, 0x02	; 2
 5e0:	ce 01       	movw	r24, r28
 5e2:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
}
 5e6:	df 91       	pop	r29
 5e8:	cf 91       	pop	r28
 5ea:	1f 91       	pop	r17
 5ec:	08 95       	ret

000005ee <_ZN4RF2414startListeningEv>:
}

/****************************************************************************/

void RF24::startListening(void)
{
 5ee:	cf 93       	push	r28
 5f0:	df 93       	push	r29
 5f2:	ec 01       	movw	r28, r24
 #if !defined (RF24_TINY) && ! defined(LITTLEWIRE)
  powerUp();
 5f4:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN4RF247powerUpEv>
 #endif
  write_register(CONFIG, read_register(CONFIG) | _BV(PRIM_RX));
 5f8:	60 e0       	ldi	r22, 0x00	; 0
 5fa:	ce 01       	movw	r24, r28
 5fc:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 600:	48 2f       	mov	r20, r24
 602:	41 60       	ori	r20, 0x01	; 1
 604:	60 e0       	ldi	r22, 0x00	; 0
 606:	ce 01       	movw	r24, r28
 608:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
  write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT) );
 60c:	40 e7       	ldi	r20, 0x70	; 112
 60e:	67 e0       	ldi	r22, 0x07	; 7
 610:	ce 01       	movw	r24, r28
 612:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
  ce(HIGH);
 616:	61 e0       	ldi	r22, 0x01	; 1
 618:	ce 01       	movw	r24, r28
 61a:	0e 94 84 01 	call	0x308	; 0x308 <_ZN4RF242ceEb>
  // Restore the pipe0 adddress, if exists
  if (pipe0_reading_address[0] > 0){
 61e:	8d 81       	ldd	r24, Y+5	; 0x05
 620:	88 23       	and	r24, r24
 622:	49 f0       	breq	.+18     	; 0x636 <_ZN4RF2414startListeningEv+0x48>
    write_register(RX_ADDR_P0, pipe0_reading_address, addr_width);	
 624:	2a 85       	ldd	r18, Y+10	; 0x0a
 626:	ae 01       	movw	r20, r28
 628:	4b 5f       	subi	r20, 0xFB	; 251
 62a:	5f 4f       	sbci	r21, 0xFF	; 255
 62c:	6a e0       	ldi	r22, 0x0A	; 10
 62e:	ce 01       	movw	r24, r28
 630:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN4RF2414write_registerEhPKhh>
 634:	04 c0       	rjmp	.+8      	; 0x63e <_ZN4RF2414startListeningEv+0x50>
  }else{
	closeReadingPipe(0);
 636:	60 e0       	ldi	r22, 0x00	; 0
 638:	ce 01       	movw	r24, r28
 63a:	0e 94 d6 02 	call	0x5ac	; 0x5ac <_ZN4RF2416closeReadingPipeEh>
  }

  // Flush buffers
  //flush_rx();
  if(read_register(FEATURE) & _BV(EN_ACK_PAY)){
 63e:	6d e1       	ldi	r22, 0x1D	; 29
 640:	ce 01       	movw	r24, r28
 642:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 646:	81 ff       	sbrs	r24, 1
 648:	03 c0       	rjmp	.+6      	; 0x650 <_ZN4RF2414startListeningEv+0x62>
	flush_tx();
 64a:	ce 01       	movw	r24, r28
 64c:	0e 94 3a 02 	call	0x474	; 0x474 <_ZN4RF248flush_txEv>
  }

  // Go!
  //delayMicroseconds(100);
}
 650:	df 91       	pop	r29
 652:	cf 91       	pop	r28
 654:	08 95       	ret

00000656 <_ZN4RF2415toggle_featuresEv>:
}

/****************************************************************************/

void RF24::toggle_features(void)
{
 656:	cf 93       	push	r28
 658:	df 93       	push	r29
 65a:	ec 01       	movw	r28, r24
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 65c:	84 b1       	in	r24, 0x04	; 4
 65e:	8c 62       	ori	r24, 0x2C	; 44
 660:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 662:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 664:	8c b5       	in	r24, 0x2c	; 44
 666:	80 65       	ori	r24, 0x50	; 80
 668:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 66a:	60 e0       	ldi	r22, 0x00	; 0
 66c:	ce 01       	movw	r24, r28
 66e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 672:	80 e5       	ldi	r24, 0x50	; 80
 674:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 676:	0d b4       	in	r0, 0x2d	; 45
 678:	07 fe       	sbrs	r0, 7
 67a:	fd cf       	rjmp	.-6      	; 0x676 <_ZN4RF2415toggle_featuresEv+0x20>
	return SPDR;
 67c:	8e b5       	in	r24, 0x2e	; 46
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 67e:	83 e7       	ldi	r24, 0x73	; 115
 680:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 682:	0d b4       	in	r0, 0x2d	; 45
 684:	07 fe       	sbrs	r0, 7
 686:	fd cf       	rjmp	.-6      	; 0x682 <_ZN4RF2415toggle_featuresEv+0x2c>
	return SPDR;
 688:	8e b5       	in	r24, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 68a:	61 e0       	ldi	r22, 0x01	; 1
 68c:	ce 01       	movw	r24, r28
 68e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
	_SPI.transfer( ACTIVATE );
    _SPI.transfer( 0x73 );
	endTransaction();
  #endif

}
 692:	df 91       	pop	r29
 694:	cf 91       	pop	r28
 696:	08 95       	ret

00000698 <_ZN4RF2410setPALevelEh>:
}

/****************************************************************************/

void RF24::setPALevel(uint8_t level)
{
 698:	1f 93       	push	r17
 69a:	cf 93       	push	r28
 69c:	df 93       	push	r29
 69e:	ec 01       	movw	r28, r24
 6a0:	16 2f       	mov	r17, r22

  uint8_t setup = read_register(RF_SETUP) & 0b11111000;
 6a2:	66 e0       	ldi	r22, 0x06	; 6
 6a4:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 6a8:	88 7f       	andi	r24, 0xF8	; 248

  if(level > 3){  						// If invalid level, go to max PA
 6aa:	14 30       	cpi	r17, 0x04	; 4
 6ac:	20 f4       	brcc	.+8      	; 0x6b6 <_ZN4RF2410setPALevelEh+0x1e>
	  level = (RF24_PA_MAX << 1) + 1;		// +1 to support the SI24R1 chip extra bit
  }else{
	  level = (level << 1) + 1;	 		// Else set level as requested
 6ae:	41 2f       	mov	r20, r17
 6b0:	44 0f       	add	r20, r20
 6b2:	4f 5f       	subi	r20, 0xFF	; 255
 6b4:	01 c0       	rjmp	.+2      	; 0x6b8 <_ZN4RF2410setPALevelEh+0x20>
{

  uint8_t setup = read_register(RF_SETUP) & 0b11111000;

  if(level > 3){  						// If invalid level, go to max PA
	  level = (RF24_PA_MAX << 1) + 1;		// +1 to support the SI24R1 chip extra bit
 6b6:	47 e0       	ldi	r20, 0x07	; 7
  }else{
	  level = (level << 1) + 1;	 		// Else set level as requested
  }


  write_register( RF_SETUP, setup |= level ) ;	// Write it to the chip
 6b8:	48 2b       	or	r20, r24
 6ba:	66 e0       	ldi	r22, 0x06	; 6
 6bc:	ce 01       	movw	r24, r28
 6be:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
}
 6c2:	df 91       	pop	r29
 6c4:	cf 91       	pop	r28
 6c6:	1f 91       	pop	r17
 6c8:	08 95       	ret

000006ca <_ZN4RF2411setDataRateE15rf24_datarate_e>:
}

/****************************************************************************/

bool RF24::setDataRate(rf24_datarate_e speed)
{
 6ca:	ff 92       	push	r15
 6cc:	0f 93       	push	r16
 6ce:	1f 93       	push	r17
 6d0:	cf 93       	push	r28
 6d2:	df 93       	push	r29
 6d4:	ec 01       	movw	r28, r24
 6d6:	16 2f       	mov	r17, r22
  bool result = false;
  uint8_t setup = read_register(RF_SETUP) ;
 6d8:	66 e0       	ldi	r22, 0x06	; 6
 6da:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>

  // HIGH and LOW '00' is 1Mbs - our default
  setup &= ~(_BV(RF_DR_LOW) | _BV(RF_DR_HIGH)) ;
 6de:	87 7d       	andi	r24, 0xD7	; 215
 6e0:	f8 2e       	mov	r15, r24
  #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
    txRxDelay=250;
  #else //16Mhz Arduino
    txRxDelay=85;
  #endif
  if( speed == RF24_250KBPS )
 6e2:	12 30       	cpi	r17, 0x02	; 2
 6e4:	59 f4       	brne	.+22     	; 0x6fc <_ZN4RF2411setDataRateE15rf24_datarate_e+0x32>
  {
    // Must set the RF_DR_LOW to 1; RF_DR_HIGH (used to be RF_DR) is already 0
    // Making it '10'.
    setup |= _BV( RF_DR_LOW ) ;
 6e6:	80 62       	ori	r24, 0x20	; 32
 6e8:	f8 2e       	mov	r15, r24
  #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
    txRxDelay=450;
  #else //16Mhz Arduino
	txRxDelay=155;
 6ea:	0b e9       	ldi	r16, 0x9B	; 155
 6ec:	10 e0       	ldi	r17, 0x00	; 0
 6ee:	20 e0       	ldi	r18, 0x00	; 0
 6f0:	30 e0       	ldi	r19, 0x00	; 0
 6f2:	0b 87       	std	Y+11, r16	; 0x0b
 6f4:	1c 87       	std	Y+12, r17	; 0x0c
 6f6:	2d 87       	std	Y+13, r18	; 0x0d
 6f8:	3e 87       	std	Y+14, r19	; 0x0e
 6fa:	15 c0       	rjmp	.+42     	; 0x726 <_ZN4RF2411setDataRateE15rf24_datarate_e+0x5c>
  }
  else
  {
    // Set 2Mbs, RF_DR (RF_DR_HIGH) is set 1
    // Making it '01'
    if ( speed == RF24_2MBPS )
 6fc:	11 30       	cpi	r17, 0x01	; 1
 6fe:	49 f0       	breq	.+18     	; 0x712 <_ZN4RF2411setDataRateE15rf24_datarate_e+0x48>
  setup &= ~(_BV(RF_DR_LOW) | _BV(RF_DR_HIGH)) ;
  
  #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
    txRxDelay=250;
  #else //16Mhz Arduino
    txRxDelay=85;
 700:	05 e5       	ldi	r16, 0x55	; 85
 702:	10 e0       	ldi	r17, 0x00	; 0
 704:	20 e0       	ldi	r18, 0x00	; 0
 706:	30 e0       	ldi	r19, 0x00	; 0
 708:	0b 87       	std	Y+11, r16	; 0x0b
 70a:	1c 87       	std	Y+12, r17	; 0x0c
 70c:	2d 87       	std	Y+13, r18	; 0x0d
 70e:	3e 87       	std	Y+14, r19	; 0x0e
 710:	0a c0       	rjmp	.+20     	; 0x726 <_ZN4RF2411setDataRateE15rf24_datarate_e+0x5c>
  {
    // Set 2Mbs, RF_DR (RF_DR_HIGH) is set 1
    // Making it '01'
    if ( speed == RF24_2MBPS )
    {
      setup |= _BV(RF_DR_HIGH);
 712:	88 60       	ori	r24, 0x08	; 8
 714:	f8 2e       	mov	r15, r24
      #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
      txRxDelay=190;
      #else //16Mhz Arduino	  
	  txRxDelay=65;
 716:	01 e4       	ldi	r16, 0x41	; 65
 718:	10 e0       	ldi	r17, 0x00	; 0
 71a:	20 e0       	ldi	r18, 0x00	; 0
 71c:	30 e0       	ldi	r19, 0x00	; 0
 71e:	0b 87       	std	Y+11, r16	; 0x0b
 720:	1c 87       	std	Y+12, r17	; 0x0c
 722:	2d 87       	std	Y+13, r18	; 0x0d
 724:	3e 87       	std	Y+14, r19	; 0x0e
	  #endif
    }
  }
  write_register(RF_SETUP,setup);
 726:	4f 2d       	mov	r20, r15
 728:	66 e0       	ldi	r22, 0x06	; 6
 72a:	ce 01       	movw	r24, r28
 72c:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>

  // Verify our result
  if ( read_register(RF_SETUP) == setup )
 730:	66 e0       	ldi	r22, 0x06	; 6
 732:	ce 01       	movw	r24, r28
 734:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 738:	91 e0       	ldi	r25, 0x01	; 1
 73a:	f8 12       	cpse	r15, r24
 73c:	90 e0       	ldi	r25, 0x00	; 0
  {
    result = true;
  }
  return result;
}
 73e:	89 2f       	mov	r24, r25
 740:	df 91       	pop	r29
 742:	cf 91       	pop	r28
 744:	1f 91       	pop	r17
 746:	0f 91       	pop	r16
 748:	ff 90       	pop	r15
 74a:	08 95       	ret

0000074c <_ZN4RF245beginEv>:

#endif
/****************************************************************************/

bool RF24::begin(void)
{
 74c:	cf 93       	push	r28
 74e:	df 93       	push	r29
 750:	ec 01       	movw	r28, r24
  #elif defined(LITTLEWIRE)
    pinMode(csn_pin,OUTPUT);
    _SPI.begin();
    csn(HIGH);
  #elif defined(__AVR__)
	CE_DDR |= (1<<CE_BIT);
 752:	57 9a       	sbi	0x0a, 7	; 10
	CSN_DDR|=(1<<CSN_BIT);
 754:	20 9a       	sbi	0x04, 0	; 4
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 756:	84 b1       	in	r24, 0x04	; 4
 758:	8c 62       	ori	r24, 0x2C	; 44
 75a:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 75c:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 75e:	8c b5       	in	r24, 0x2c	; 44
 760:	80 65       	ori	r24, 0x50	; 80
 762:	8c bd       	out	0x2c, r24	; 44
	spi_master_initialize();
	csn(HIGH);
 764:	61 e0       	ldi	r22, 0x01	; 1
 766:	ce 01       	movw	r24, r28
 768:	0e 94 74 01 	call	0x2e8	; 0x2e8 <_ZN4RF243csnEb>
 76c:	8f e0       	ldi	r24, 0x0F	; 15
 76e:	97 e2       	ldi	r25, 0x27	; 39
 770:	01 97       	sbiw	r24, 0x01	; 1
 772:	f1 f7       	brne	.-4      	; 0x770 <_ZN4RF245beginEv+0x24>
 774:	00 c0       	rjmp	.+0      	; 0x776 <_ZN4RF245beginEv+0x2a>
 776:	00 00       	nop
  #else
  delay( 5 ) ;
  #endif

  // Reset CONFIG and enable 16-bit CRC.
  write_register( CONFIG, 0b00001100 ) ;
 778:	4c e0       	ldi	r20, 0x0C	; 12
 77a:	60 e0       	ldi	r22, 0x00	; 0
 77c:	ce 01       	movw	r24, r28
 77e:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
}

/****************************************************************************/
void RF24::setRetries(uint8_t delay, uint8_t count)
{
 write_register(SETUP_RETR,(delay&0xf)<<ARD | (count&0xf)<<ARC);
 782:	4f e5       	ldi	r20, 0x5F	; 95
 784:	64 e0       	ldi	r22, 0x04	; 4
 786:	ce 01       	movw	r24, r28
 788:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
  // Reset value is MAX
  //setPALevel( RF24_PA_MAX ) ;

  // check for connected module and if this is a p nRF24l01 variant
  //
  if( setDataRate( RF24_250KBPS ) )
 78c:	62 e0       	ldi	r22, 0x02	; 2
 78e:	ce 01       	movw	r24, r28
 790:	0e 94 65 03 	call	0x6ca	; 0x6ca <_ZN4RF2411setDataRateE15rf24_datarate_e>
 794:	88 23       	and	r24, r24
 796:	11 f0       	breq	.+4      	; 0x79c <_ZN4RF245beginEv+0x50>
  {
    p_variant = true ;
 798:	81 e0       	ldi	r24, 0x01	; 1
 79a:	8a 83       	std	Y+2, r24	; 0x02
    p_variant = true ;
  }*/
  
  // Then set the data rate to the slowest (and most reliable) speed supported by all
  // hardware.
  setDataRate( RF24_1MBPS ) ;
 79c:	60 e0       	ldi	r22, 0x00	; 0
 79e:	ce 01       	movw	r24, r28
 7a0:	0e 94 65 03 	call	0x6ca	; 0x6ca <_ZN4RF2411setDataRateE15rf24_datarate_e>

  // Initialize CRC and request 2-byte (16bit) CRC
  //setCRCLength( RF24_CRC_16 ) ;

  // Disable dynamic payloads, to match dynamic_payloads_enabled setting - Reset value is 0
  toggle_features();
 7a4:	ce 01       	movw	r24, r28
 7a6:	0e 94 2b 03 	call	0x656	; 0x656 <_ZN4RF2415toggle_featuresEv>
  write_register(FEATURE,0 );
 7aa:	40 e0       	ldi	r20, 0x00	; 0
 7ac:	6d e1       	ldi	r22, 0x1D	; 29
 7ae:	ce 01       	movw	r24, r28
 7b0:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>
  write_register(DYNPD,0);
 7b4:	40 e0       	ldi	r20, 0x00	; 0
 7b6:	6c e1       	ldi	r22, 0x1C	; 28
 7b8:	ce 01       	movw	r24, r28
 7ba:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>

  // Reset current status
  // Notice reset and flush is the last thing we do
  write_register(NRF_STATUS,_BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT) );
 7be:	40 e7       	ldi	r20, 0x70	; 112
 7c0:	67 e0       	ldi	r22, 0x07	; 7
 7c2:	ce 01       	movw	r24, r28
 7c4:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>

  // Set up default configuration.  Callers can always change it later.
  // This channel should be universally safe and not bleed over into adjacent
  // spectrum.
  setChannel(76);
 7c8:	6c e4       	ldi	r22, 0x4C	; 76
 7ca:	ce 01       	movw	r24, r28
 7cc:	0e 94 47 02 	call	0x48e	; 0x48e <_ZN4RF2410setChannelEh>

  // Flush buffers
  flush_rx();
 7d0:	ce 01       	movw	r24, r28
 7d2:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN4RF248flush_rxEv>
  flush_tx();
 7d6:	ce 01       	movw	r24, r28
 7d8:	0e 94 3a 02 	call	0x474	; 0x474 <_ZN4RF248flush_txEv>

  powerUp(); //Power up by default when begin() is called
 7dc:	ce 01       	movw	r24, r28
 7de:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN4RF247powerUpEv>

  // Enable PTX, do not write CE high so radio will remain in standby I mode ( 130us max to transition to RX or TX instead of 1500us from powerUp )
  // PTX should use only 22uA of power
  write_register(CONFIG, ( read_register(CONFIG) ) & ~_BV(PRIM_RX) );
 7e2:	60 e0       	ldi	r22, 0x00	; 0
 7e4:	ce 01       	movw	r24, r28
 7e6:	0e 94 94 01 	call	0x328	; 0x328 <_ZN4RF2413read_registerEh>
 7ea:	48 2f       	mov	r20, r24
 7ec:	4e 7f       	andi	r20, 0xFE	; 254
 7ee:	60 e0       	ldi	r22, 0x00	; 0
 7f0:	ce 01       	movw	r24, r28
 7f2:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_ZN4RF2414write_registerEhh>

  // if setup is 0 or ff then there was no response from module
  return ( setup != 0 && setup != 0xff );
}
 7f6:	80 e0       	ldi	r24, 0x00	; 0
 7f8:	df 91       	pop	r29
 7fa:	cf 91       	pop	r28
 7fc:	08 95       	ret

000007fe <__tablejump2__>:
 7fe:	ee 0f       	add	r30, r30
 800:	ff 1f       	adc	r31, r31

00000802 <__tablejump__>:
 802:	05 90       	lpm	r0, Z+
 804:	f4 91       	lpm	r31, Z
 806:	e0 2d       	mov	r30, r0
 808:	09 94       	ijmp

0000080a <memcpy>:
 80a:	fb 01       	movw	r30, r22
 80c:	dc 01       	movw	r26, r24
 80e:	02 c0       	rjmp	.+4      	; 0x814 <memcpy+0xa>
 810:	01 90       	ld	r0, Z+
 812:	0d 92       	st	X+, r0
 814:	41 50       	subi	r20, 0x01	; 1
 816:	50 40       	sbci	r21, 0x00	; 0
 818:	d8 f7       	brcc	.-10     	; 0x810 <memcpy+0x6>
 81a:	08 95       	ret

0000081c <fdevopen>:
 81c:	0f 93       	push	r16
 81e:	1f 93       	push	r17
 820:	cf 93       	push	r28
 822:	df 93       	push	r29
 824:	ec 01       	movw	r28, r24
 826:	8b 01       	movw	r16, r22
 828:	00 97       	sbiw	r24, 0x00	; 0
 82a:	31 f4       	brne	.+12     	; 0x838 <fdevopen+0x1c>
 82c:	61 15       	cp	r22, r1
 82e:	71 05       	cpc	r23, r1
 830:	19 f4       	brne	.+6      	; 0x838 <fdevopen+0x1c>
 832:	80 e0       	ldi	r24, 0x00	; 0
 834:	90 e0       	ldi	r25, 0x00	; 0
 836:	38 c0       	rjmp	.+112    	; 0x8a8 <fdevopen+0x8c>
 838:	6e e0       	ldi	r22, 0x0E	; 14
 83a:	70 e0       	ldi	r23, 0x00	; 0
 83c:	81 e0       	ldi	r24, 0x01	; 1
 83e:	90 e0       	ldi	r25, 0x00	; 0
 840:	0e 94 86 04 	call	0x90c	; 0x90c <calloc>
 844:	fc 01       	movw	r30, r24
 846:	00 97       	sbiw	r24, 0x00	; 0
 848:	a1 f3       	breq	.-24     	; 0x832 <fdevopen+0x16>
 84a:	80 e8       	ldi	r24, 0x80	; 128
 84c:	83 83       	std	Z+3, r24	; 0x03
 84e:	01 15       	cp	r16, r1
 850:	11 05       	cpc	r17, r1
 852:	71 f0       	breq	.+28     	; 0x870 <fdevopen+0x54>
 854:	13 87       	std	Z+11, r17	; 0x0b
 856:	02 87       	std	Z+10, r16	; 0x0a
 858:	81 e8       	ldi	r24, 0x81	; 129
 85a:	83 83       	std	Z+3, r24	; 0x03
 85c:	80 91 8d 01 	lds	r24, 0x018D
 860:	90 91 8e 01 	lds	r25, 0x018E
 864:	89 2b       	or	r24, r25
 866:	21 f4       	brne	.+8      	; 0x870 <fdevopen+0x54>
 868:	f0 93 8e 01 	sts	0x018E, r31
 86c:	e0 93 8d 01 	sts	0x018D, r30
 870:	20 97       	sbiw	r28, 0x00	; 0
 872:	c9 f0       	breq	.+50     	; 0x8a6 <fdevopen+0x8a>
 874:	d1 87       	std	Z+9, r29	; 0x09
 876:	c0 87       	std	Z+8, r28	; 0x08
 878:	83 81       	ldd	r24, Z+3	; 0x03
 87a:	82 60       	ori	r24, 0x02	; 2
 87c:	83 83       	std	Z+3, r24	; 0x03
 87e:	80 91 8f 01 	lds	r24, 0x018F
 882:	90 91 90 01 	lds	r25, 0x0190
 886:	89 2b       	or	r24, r25
 888:	71 f4       	brne	.+28     	; 0x8a6 <fdevopen+0x8a>
 88a:	f0 93 90 01 	sts	0x0190, r31
 88e:	e0 93 8f 01 	sts	0x018F, r30
 892:	80 91 91 01 	lds	r24, 0x0191
 896:	90 91 92 01 	lds	r25, 0x0192
 89a:	89 2b       	or	r24, r25
 89c:	21 f4       	brne	.+8      	; 0x8a6 <fdevopen+0x8a>
 89e:	f0 93 92 01 	sts	0x0192, r31
 8a2:	e0 93 91 01 	sts	0x0191, r30
 8a6:	cf 01       	movw	r24, r30
 8a8:	df 91       	pop	r29
 8aa:	cf 91       	pop	r28
 8ac:	1f 91       	pop	r17
 8ae:	0f 91       	pop	r16
 8b0:	08 95       	ret

000008b2 <puts>:
 8b2:	0f 93       	push	r16
 8b4:	1f 93       	push	r17
 8b6:	cf 93       	push	r28
 8b8:	df 93       	push	r29
 8ba:	e0 91 8f 01 	lds	r30, 0x018F
 8be:	f0 91 90 01 	lds	r31, 0x0190
 8c2:	23 81       	ldd	r18, Z+3	; 0x03
 8c4:	21 ff       	sbrs	r18, 1
 8c6:	1b c0       	rjmp	.+54     	; 0x8fe <puts+0x4c>
 8c8:	ec 01       	movw	r28, r24
 8ca:	00 e0       	ldi	r16, 0x00	; 0
 8cc:	10 e0       	ldi	r17, 0x00	; 0
 8ce:	89 91       	ld	r24, Y+
 8d0:	60 91 8f 01 	lds	r22, 0x018F
 8d4:	70 91 90 01 	lds	r23, 0x0190
 8d8:	db 01       	movw	r26, r22
 8da:	18 96       	adiw	r26, 0x08	; 8
 8dc:	ed 91       	ld	r30, X+
 8de:	fc 91       	ld	r31, X
 8e0:	19 97       	sbiw	r26, 0x09	; 9
 8e2:	88 23       	and	r24, r24
 8e4:	31 f0       	breq	.+12     	; 0x8f2 <puts+0x40>
 8e6:	09 95       	icall
 8e8:	89 2b       	or	r24, r25
 8ea:	89 f3       	breq	.-30     	; 0x8ce <puts+0x1c>
 8ec:	0f ef       	ldi	r16, 0xFF	; 255
 8ee:	1f ef       	ldi	r17, 0xFF	; 255
 8f0:	ee cf       	rjmp	.-36     	; 0x8ce <puts+0x1c>
 8f2:	8a e0       	ldi	r24, 0x0A	; 10
 8f4:	09 95       	icall
 8f6:	89 2b       	or	r24, r25
 8f8:	11 f4       	brne	.+4      	; 0x8fe <puts+0x4c>
 8fa:	c8 01       	movw	r24, r16
 8fc:	02 c0       	rjmp	.+4      	; 0x902 <__stack+0x3>
 8fe:	8f ef       	ldi	r24, 0xFF	; 255
 900:	9f ef       	ldi	r25, 0xFF	; 255
 902:	df 91       	pop	r29
 904:	cf 91       	pop	r28
 906:	1f 91       	pop	r17
 908:	0f 91       	pop	r16
 90a:	08 95       	ret

0000090c <calloc>:
 90c:	0f 93       	push	r16
 90e:	1f 93       	push	r17
 910:	cf 93       	push	r28
 912:	df 93       	push	r29
 914:	86 9f       	mul	r24, r22
 916:	80 01       	movw	r16, r0
 918:	87 9f       	mul	r24, r23
 91a:	10 0d       	add	r17, r0
 91c:	96 9f       	mul	r25, r22
 91e:	10 0d       	add	r17, r0
 920:	11 24       	eor	r1, r1
 922:	c8 01       	movw	r24, r16
 924:	0e 94 a2 04 	call	0x944	; 0x944 <malloc>
 928:	ec 01       	movw	r28, r24
 92a:	00 97       	sbiw	r24, 0x00	; 0
 92c:	29 f0       	breq	.+10     	; 0x938 <calloc+0x2c>
 92e:	a8 01       	movw	r20, r16
 930:	60 e0       	ldi	r22, 0x00	; 0
 932:	70 e0       	ldi	r23, 0x00	; 0
 934:	0e 94 c9 05 	call	0xb92	; 0xb92 <memset>
 938:	ce 01       	movw	r24, r28
 93a:	df 91       	pop	r29
 93c:	cf 91       	pop	r28
 93e:	1f 91       	pop	r17
 940:	0f 91       	pop	r16
 942:	08 95       	ret

00000944 <malloc>:
 944:	cf 93       	push	r28
 946:	df 93       	push	r29
 948:	82 30       	cpi	r24, 0x02	; 2
 94a:	91 05       	cpc	r25, r1
 94c:	10 f4       	brcc	.+4      	; 0x952 <malloc+0xe>
 94e:	82 e0       	ldi	r24, 0x02	; 2
 950:	90 e0       	ldi	r25, 0x00	; 0
 952:	e0 91 95 01 	lds	r30, 0x0195
 956:	f0 91 96 01 	lds	r31, 0x0196
 95a:	20 e0       	ldi	r18, 0x00	; 0
 95c:	30 e0       	ldi	r19, 0x00	; 0
 95e:	a0 e0       	ldi	r26, 0x00	; 0
 960:	b0 e0       	ldi	r27, 0x00	; 0
 962:	30 97       	sbiw	r30, 0x00	; 0
 964:	39 f1       	breq	.+78     	; 0x9b4 <malloc+0x70>
 966:	40 81       	ld	r20, Z
 968:	51 81       	ldd	r21, Z+1	; 0x01
 96a:	48 17       	cp	r20, r24
 96c:	59 07       	cpc	r21, r25
 96e:	b8 f0       	brcs	.+46     	; 0x99e <malloc+0x5a>
 970:	48 17       	cp	r20, r24
 972:	59 07       	cpc	r21, r25
 974:	71 f4       	brne	.+28     	; 0x992 <malloc+0x4e>
 976:	82 81       	ldd	r24, Z+2	; 0x02
 978:	93 81       	ldd	r25, Z+3	; 0x03
 97a:	10 97       	sbiw	r26, 0x00	; 0
 97c:	29 f0       	breq	.+10     	; 0x988 <malloc+0x44>
 97e:	13 96       	adiw	r26, 0x03	; 3
 980:	9c 93       	st	X, r25
 982:	8e 93       	st	-X, r24
 984:	12 97       	sbiw	r26, 0x02	; 2
 986:	2c c0       	rjmp	.+88     	; 0x9e0 <malloc+0x9c>
 988:	90 93 96 01 	sts	0x0196, r25
 98c:	80 93 95 01 	sts	0x0195, r24
 990:	27 c0       	rjmp	.+78     	; 0x9e0 <malloc+0x9c>
 992:	21 15       	cp	r18, r1
 994:	31 05       	cpc	r19, r1
 996:	31 f0       	breq	.+12     	; 0x9a4 <malloc+0x60>
 998:	42 17       	cp	r20, r18
 99a:	53 07       	cpc	r21, r19
 99c:	18 f0       	brcs	.+6      	; 0x9a4 <malloc+0x60>
 99e:	a9 01       	movw	r20, r18
 9a0:	db 01       	movw	r26, r22
 9a2:	01 c0       	rjmp	.+2      	; 0x9a6 <malloc+0x62>
 9a4:	ef 01       	movw	r28, r30
 9a6:	9a 01       	movw	r18, r20
 9a8:	bd 01       	movw	r22, r26
 9aa:	df 01       	movw	r26, r30
 9ac:	02 80       	ldd	r0, Z+2	; 0x02
 9ae:	f3 81       	ldd	r31, Z+3	; 0x03
 9b0:	e0 2d       	mov	r30, r0
 9b2:	d7 cf       	rjmp	.-82     	; 0x962 <malloc+0x1e>
 9b4:	21 15       	cp	r18, r1
 9b6:	31 05       	cpc	r19, r1
 9b8:	f9 f0       	breq	.+62     	; 0x9f8 <malloc+0xb4>
 9ba:	28 1b       	sub	r18, r24
 9bc:	39 0b       	sbc	r19, r25
 9be:	24 30       	cpi	r18, 0x04	; 4
 9c0:	31 05       	cpc	r19, r1
 9c2:	80 f4       	brcc	.+32     	; 0x9e4 <malloc+0xa0>
 9c4:	8a 81       	ldd	r24, Y+2	; 0x02
 9c6:	9b 81       	ldd	r25, Y+3	; 0x03
 9c8:	61 15       	cp	r22, r1
 9ca:	71 05       	cpc	r23, r1
 9cc:	21 f0       	breq	.+8      	; 0x9d6 <malloc+0x92>
 9ce:	fb 01       	movw	r30, r22
 9d0:	93 83       	std	Z+3, r25	; 0x03
 9d2:	82 83       	std	Z+2, r24	; 0x02
 9d4:	04 c0       	rjmp	.+8      	; 0x9de <malloc+0x9a>
 9d6:	90 93 96 01 	sts	0x0196, r25
 9da:	80 93 95 01 	sts	0x0195, r24
 9de:	fe 01       	movw	r30, r28
 9e0:	32 96       	adiw	r30, 0x02	; 2
 9e2:	44 c0       	rjmp	.+136    	; 0xa6c <malloc+0x128>
 9e4:	fe 01       	movw	r30, r28
 9e6:	e2 0f       	add	r30, r18
 9e8:	f3 1f       	adc	r31, r19
 9ea:	81 93       	st	Z+, r24
 9ec:	91 93       	st	Z+, r25
 9ee:	22 50       	subi	r18, 0x02	; 2
 9f0:	31 09       	sbc	r19, r1
 9f2:	39 83       	std	Y+1, r19	; 0x01
 9f4:	28 83       	st	Y, r18
 9f6:	3a c0       	rjmp	.+116    	; 0xa6c <malloc+0x128>
 9f8:	20 91 93 01 	lds	r18, 0x0193
 9fc:	30 91 94 01 	lds	r19, 0x0194
 a00:	23 2b       	or	r18, r19
 a02:	41 f4       	brne	.+16     	; 0xa14 <malloc+0xd0>
 a04:	20 91 02 01 	lds	r18, 0x0102
 a08:	30 91 03 01 	lds	r19, 0x0103
 a0c:	30 93 94 01 	sts	0x0194, r19
 a10:	20 93 93 01 	sts	0x0193, r18
 a14:	20 91 00 01 	lds	r18, 0x0100
 a18:	30 91 01 01 	lds	r19, 0x0101
 a1c:	21 15       	cp	r18, r1
 a1e:	31 05       	cpc	r19, r1
 a20:	41 f4       	brne	.+16     	; 0xa32 <malloc+0xee>
 a22:	2d b7       	in	r18, 0x3d	; 61
 a24:	3e b7       	in	r19, 0x3e	; 62
 a26:	40 91 04 01 	lds	r20, 0x0104
 a2a:	50 91 05 01 	lds	r21, 0x0105
 a2e:	24 1b       	sub	r18, r20
 a30:	35 0b       	sbc	r19, r21
 a32:	e0 91 93 01 	lds	r30, 0x0193
 a36:	f0 91 94 01 	lds	r31, 0x0194
 a3a:	e2 17       	cp	r30, r18
 a3c:	f3 07       	cpc	r31, r19
 a3e:	a0 f4       	brcc	.+40     	; 0xa68 <malloc+0x124>
 a40:	2e 1b       	sub	r18, r30
 a42:	3f 0b       	sbc	r19, r31
 a44:	28 17       	cp	r18, r24
 a46:	39 07       	cpc	r19, r25
 a48:	78 f0       	brcs	.+30     	; 0xa68 <malloc+0x124>
 a4a:	ac 01       	movw	r20, r24
 a4c:	4e 5f       	subi	r20, 0xFE	; 254
 a4e:	5f 4f       	sbci	r21, 0xFF	; 255
 a50:	24 17       	cp	r18, r20
 a52:	35 07       	cpc	r19, r21
 a54:	48 f0       	brcs	.+18     	; 0xa68 <malloc+0x124>
 a56:	4e 0f       	add	r20, r30
 a58:	5f 1f       	adc	r21, r31
 a5a:	50 93 94 01 	sts	0x0194, r21
 a5e:	40 93 93 01 	sts	0x0193, r20
 a62:	81 93       	st	Z+, r24
 a64:	91 93       	st	Z+, r25
 a66:	02 c0       	rjmp	.+4      	; 0xa6c <malloc+0x128>
 a68:	e0 e0       	ldi	r30, 0x00	; 0
 a6a:	f0 e0       	ldi	r31, 0x00	; 0
 a6c:	cf 01       	movw	r24, r30
 a6e:	df 91       	pop	r29
 a70:	cf 91       	pop	r28
 a72:	08 95       	ret

00000a74 <free>:
 a74:	cf 93       	push	r28
 a76:	df 93       	push	r29
 a78:	00 97       	sbiw	r24, 0x00	; 0
 a7a:	09 f4       	brne	.+2      	; 0xa7e <free+0xa>
 a7c:	87 c0       	rjmp	.+270    	; 0xb8c <free+0x118>
 a7e:	fc 01       	movw	r30, r24
 a80:	32 97       	sbiw	r30, 0x02	; 2
 a82:	13 82       	std	Z+3, r1	; 0x03
 a84:	12 82       	std	Z+2, r1	; 0x02
 a86:	c0 91 95 01 	lds	r28, 0x0195
 a8a:	d0 91 96 01 	lds	r29, 0x0196
 a8e:	20 97       	sbiw	r28, 0x00	; 0
 a90:	81 f4       	brne	.+32     	; 0xab2 <free+0x3e>
 a92:	20 81       	ld	r18, Z
 a94:	31 81       	ldd	r19, Z+1	; 0x01
 a96:	28 0f       	add	r18, r24
 a98:	39 1f       	adc	r19, r25
 a9a:	80 91 93 01 	lds	r24, 0x0193
 a9e:	90 91 94 01 	lds	r25, 0x0194
 aa2:	82 17       	cp	r24, r18
 aa4:	93 07       	cpc	r25, r19
 aa6:	79 f5       	brne	.+94     	; 0xb06 <free+0x92>
 aa8:	f0 93 94 01 	sts	0x0194, r31
 aac:	e0 93 93 01 	sts	0x0193, r30
 ab0:	6d c0       	rjmp	.+218    	; 0xb8c <free+0x118>
 ab2:	de 01       	movw	r26, r28
 ab4:	20 e0       	ldi	r18, 0x00	; 0
 ab6:	30 e0       	ldi	r19, 0x00	; 0
 ab8:	ae 17       	cp	r26, r30
 aba:	bf 07       	cpc	r27, r31
 abc:	50 f4       	brcc	.+20     	; 0xad2 <free+0x5e>
 abe:	12 96       	adiw	r26, 0x02	; 2
 ac0:	4d 91       	ld	r20, X+
 ac2:	5c 91       	ld	r21, X
 ac4:	13 97       	sbiw	r26, 0x03	; 3
 ac6:	9d 01       	movw	r18, r26
 ac8:	41 15       	cp	r20, r1
 aca:	51 05       	cpc	r21, r1
 acc:	09 f1       	breq	.+66     	; 0xb10 <free+0x9c>
 ace:	da 01       	movw	r26, r20
 ad0:	f3 cf       	rjmp	.-26     	; 0xab8 <free+0x44>
 ad2:	b3 83       	std	Z+3, r27	; 0x03
 ad4:	a2 83       	std	Z+2, r26	; 0x02
 ad6:	40 81       	ld	r20, Z
 ad8:	51 81       	ldd	r21, Z+1	; 0x01
 ada:	84 0f       	add	r24, r20
 adc:	95 1f       	adc	r25, r21
 ade:	8a 17       	cp	r24, r26
 ae0:	9b 07       	cpc	r25, r27
 ae2:	71 f4       	brne	.+28     	; 0xb00 <free+0x8c>
 ae4:	8d 91       	ld	r24, X+
 ae6:	9c 91       	ld	r25, X
 ae8:	11 97       	sbiw	r26, 0x01	; 1
 aea:	84 0f       	add	r24, r20
 aec:	95 1f       	adc	r25, r21
 aee:	02 96       	adiw	r24, 0x02	; 2
 af0:	91 83       	std	Z+1, r25	; 0x01
 af2:	80 83       	st	Z, r24
 af4:	12 96       	adiw	r26, 0x02	; 2
 af6:	8d 91       	ld	r24, X+
 af8:	9c 91       	ld	r25, X
 afa:	13 97       	sbiw	r26, 0x03	; 3
 afc:	93 83       	std	Z+3, r25	; 0x03
 afe:	82 83       	std	Z+2, r24	; 0x02
 b00:	21 15       	cp	r18, r1
 b02:	31 05       	cpc	r19, r1
 b04:	29 f4       	brne	.+10     	; 0xb10 <free+0x9c>
 b06:	f0 93 96 01 	sts	0x0196, r31
 b0a:	e0 93 95 01 	sts	0x0195, r30
 b0e:	3e c0       	rjmp	.+124    	; 0xb8c <free+0x118>
 b10:	d9 01       	movw	r26, r18
 b12:	13 96       	adiw	r26, 0x03	; 3
 b14:	fc 93       	st	X, r31
 b16:	ee 93       	st	-X, r30
 b18:	12 97       	sbiw	r26, 0x02	; 2
 b1a:	4d 91       	ld	r20, X+
 b1c:	5d 91       	ld	r21, X+
 b1e:	a4 0f       	add	r26, r20
 b20:	b5 1f       	adc	r27, r21
 b22:	ea 17       	cp	r30, r26
 b24:	fb 07       	cpc	r31, r27
 b26:	79 f4       	brne	.+30     	; 0xb46 <free+0xd2>
 b28:	80 81       	ld	r24, Z
 b2a:	91 81       	ldd	r25, Z+1	; 0x01
 b2c:	84 0f       	add	r24, r20
 b2e:	95 1f       	adc	r25, r21
 b30:	02 96       	adiw	r24, 0x02	; 2
 b32:	d9 01       	movw	r26, r18
 b34:	11 96       	adiw	r26, 0x01	; 1
 b36:	9c 93       	st	X, r25
 b38:	8e 93       	st	-X, r24
 b3a:	82 81       	ldd	r24, Z+2	; 0x02
 b3c:	93 81       	ldd	r25, Z+3	; 0x03
 b3e:	13 96       	adiw	r26, 0x03	; 3
 b40:	9c 93       	st	X, r25
 b42:	8e 93       	st	-X, r24
 b44:	12 97       	sbiw	r26, 0x02	; 2
 b46:	e0 e0       	ldi	r30, 0x00	; 0
 b48:	f0 e0       	ldi	r31, 0x00	; 0
 b4a:	8a 81       	ldd	r24, Y+2	; 0x02
 b4c:	9b 81       	ldd	r25, Y+3	; 0x03
 b4e:	00 97       	sbiw	r24, 0x00	; 0
 b50:	19 f0       	breq	.+6      	; 0xb58 <free+0xe4>
 b52:	fe 01       	movw	r30, r28
 b54:	ec 01       	movw	r28, r24
 b56:	f9 cf       	rjmp	.-14     	; 0xb4a <free+0xd6>
 b58:	ce 01       	movw	r24, r28
 b5a:	02 96       	adiw	r24, 0x02	; 2
 b5c:	28 81       	ld	r18, Y
 b5e:	39 81       	ldd	r19, Y+1	; 0x01
 b60:	82 0f       	add	r24, r18
 b62:	93 1f       	adc	r25, r19
 b64:	20 91 93 01 	lds	r18, 0x0193
 b68:	30 91 94 01 	lds	r19, 0x0194
 b6c:	28 17       	cp	r18, r24
 b6e:	39 07       	cpc	r19, r25
 b70:	69 f4       	brne	.+26     	; 0xb8c <free+0x118>
 b72:	30 97       	sbiw	r30, 0x00	; 0
 b74:	29 f4       	brne	.+10     	; 0xb80 <free+0x10c>
 b76:	10 92 96 01 	sts	0x0196, r1
 b7a:	10 92 95 01 	sts	0x0195, r1
 b7e:	02 c0       	rjmp	.+4      	; 0xb84 <free+0x110>
 b80:	13 82       	std	Z+3, r1	; 0x03
 b82:	12 82       	std	Z+2, r1	; 0x02
 b84:	d0 93 94 01 	sts	0x0194, r29
 b88:	c0 93 93 01 	sts	0x0193, r28
 b8c:	df 91       	pop	r29
 b8e:	cf 91       	pop	r28
 b90:	08 95       	ret

00000b92 <memset>:
 b92:	dc 01       	movw	r26, r24
 b94:	01 c0       	rjmp	.+2      	; 0xb98 <memset+0x6>
 b96:	6d 93       	st	X+, r22
 b98:	41 50       	subi	r20, 0x01	; 1
 b9a:	50 40       	sbci	r21, 0x00	; 0
 b9c:	e0 f7       	brcc	.-8      	; 0xb96 <memset+0x4>
 b9e:	08 95       	ret

00000ba0 <_exit>:
 ba0:	f8 94       	cli

00000ba2 <__stop_program>:
 ba2:	ff cf       	rjmp	.-2      	; 0xba2 <__stop_program>
