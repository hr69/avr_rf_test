
nrf24l01p.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000070  00800100  00000bda  00000c6e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000bda  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000029  00800170  00800170  00000cde  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cde  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002f0  00000000  00000000  00000d0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005a7a  00000000  00000000  00000ffe  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000009f7  00000000  00000000  00006a78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d71  00000000  00000000  0000746f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000adc  00000000  00000000  000081e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000136a  00000000  00000000  00008cbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003d57  00000000  00000000  0000a026  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002d8  00000000  00000000  0000dd7d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
   8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
   c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  30:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  40:	0c 94 22 01 	jmp	0x244	; 0x244 <__vector_16>
  44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  48:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	11 12       	cpse	r1, r17
  6a:	13 14       	cp	r1, r3
  6c:	15 16       	cp	r1, r21

0000006e <_ZL10child_pipe>:
  6e:	0a 0b 0c 0d 0e 0f                                   ......

00000074 <_ZL17child_pipe_enable>:
  74:	00 01 02 03 04 05                                   ......

0000007a <__ctors_start>:
  7a:	1d 01       	movw	r2, r26

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	ea ed       	ldi	r30, 0xDA	; 218
  90:	fb e0       	ldi	r31, 0x0B	; 11
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a0 37       	cpi	r26, 0x70	; 112
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	21 e0       	ldi	r18, 0x01	; 1
  a0:	a0 e7       	ldi	r26, 0x70	; 112
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a9 39       	cpi	r26, 0x99	; 153
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>

000000ae <__do_global_ctors>:
  ae:	10 e0       	ldi	r17, 0x00	; 0
  b0:	cc e7       	ldi	r28, 0x7C	; 124
  b2:	d0 e0       	ldi	r29, 0x00	; 0
  b4:	04 c0       	rjmp	.+8      	; 0xbe <__do_global_ctors+0x10>
  b6:	22 97       	sbiw	r28, 0x02	; 2
  b8:	fe 01       	movw	r30, r28
  ba:	0e 94 1c 04 	call	0x838	; 0x838 <__tablejump__>
  be:	ca 37       	cpi	r28, 0x7A	; 122
  c0:	d1 07       	cpc	r29, r17
  c2:	c9 f7       	brne	.-14     	; 0xb6 <__do_global_ctors+0x8>
  c4:	0e 94 b3 00 	call	0x166	; 0x166 <main>
  c8:	0c 94 eb 05 	jmp	0xbd6	; 0xbd6 <_exit>

000000cc <__bad_interrupt>:
  cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <_Z23usart_transmit_byte_valh>:
/**
 * transmit byte via pass by value
 * @param data data byte to be sent
 */
void usart_transmit_byte_val(uint8_t data){
	 while (!(UCSR0A & (1<<UDRE0)));
  d0:	e0 ec       	ldi	r30, 0xC0	; 192
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	90 81       	ld	r25, Z
  d6:	95 ff       	sbrs	r25, 5
  d8:	fd cf       	rjmp	.-6      	; 0xd4 <_Z23usart_transmit_byte_valh+0x4>
	 UDR0 = data;
  da:	80 93 c6 00 	sts	0x00C6, r24
  de:	08 95       	ret

000000e0 <_Z12uart_putcharcP6__file>:

/**
 * putchar for streaming file out
 */
int uart_putchar(char ch, FILE *stream)
{
  e0:	cf 93       	push	r28
  e2:	c8 2f       	mov	r28, r24
	if(ch=='\n')
  e4:	8a 30       	cpi	r24, 0x0A	; 10
  e6:	19 f4       	brne	.+6      	; 0xee <_Z12uart_putcharcP6__file+0xe>
	uart_putchar('\r',stream);
  e8:	8d e0       	ldi	r24, 0x0D	; 13
  ea:	0e 94 70 00 	call	0xe0	; 0xe0 <_Z12uart_putcharcP6__file>
	stdio_serial_send_function((uint8_t) ch);
  ee:	8c 2f       	mov	r24, r28
  f0:	0e 94 68 00 	call	0xd0	; 0xd0 <_Z23usart_transmit_byte_valh>
	return 0;
}
  f4:	80 e0       	ldi	r24, 0x00	; 0
  f6:	90 e0       	ldi	r25, 0x00	; 0
  f8:	cf 91       	pop	r28
  fa:	08 95       	ret

000000fc <_Z22usart_receive_byte_refPh>:
/**
 * receive byte via reference
 * @param data address of data byte into which the data shall be recieved
 */
void usart_receive_byte_ref(uint8_t *data){
	 while (!(UCSR0A & (1<<RXC0)));
  fc:	e0 ec       	ldi	r30, 0xC0	; 192
  fe:	f0 e0       	ldi	r31, 0x00	; 0
 100:	20 81       	ld	r18, Z
 102:	22 23       	and	r18, r18
 104:	ec f7       	brge	.-6      	; 0x100 <_Z22usart_receive_byte_refPh+0x4>
	 *data = UDR0;
 106:	20 91 c6 00 	lds	r18, 0x00C6
 10a:	fc 01       	movw	r30, r24
 10c:	20 83       	st	Z, r18
 10e:	08 95       	ret

00000110 <_Z12uart_getcharP6__file>:
/**
 * get char for streaming file in
 */
int uart_getchar(FILE *stream)
{
 110:	0f 93       	push	r16
 112:	1f 93       	push	r17
 114:	cf 93       	push	r28
 116:	df 93       	push	r29
 118:	1f 92       	push	r1
 11a:	cd b7       	in	r28, 0x3d	; 61
 11c:	de b7       	in	r29, 0x3e	; 62
 11e:	8c 01       	movw	r16, r24
	char ch;
	stdio_serial_receive_function( (uint8_t *) &ch);
 120:	ce 01       	movw	r24, r28
 122:	01 96       	adiw	r24, 0x01	; 1
 124:	0e 94 7e 00 	call	0xfc	; 0xfc <_Z22usart_receive_byte_refPh>
	
	/* Echo the output back to the terminal */
	uart_putchar(ch,stream);
 128:	b8 01       	movw	r22, r16
 12a:	89 81       	ldd	r24, Y+1	; 0x01
 12c:	0e 94 70 00 	call	0xe0	; 0xe0 <_Z12uart_putcharcP6__file>

	return ch;
 130:	89 81       	ldd	r24, Y+1	; 0x01
}
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	0f 90       	pop	r0
 136:	df 91       	pop	r29
 138:	cf 91       	pop	r28
 13a:	1f 91       	pop	r17
 13c:	0f 91       	pop	r16
 13e:	08 95       	ret

00000140 <_Z23stdio_serial_initializev>:
/**
 * initializing the stdio file stream over uart
 */
void stdio_serial_initialize()
{
	uart_str = fdevopen(uart_putchar,uart_getchar);	
 140:	68 e8       	ldi	r22, 0x88	; 136
 142:	70 e0       	ldi	r23, 0x00	; 0
 144:	80 e7       	ldi	r24, 0x70	; 112
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	0e 94 29 04 	call	0x852	; 0x852 <fdevopen>
 14c:	90 93 82 01 	sts	0x0182, r25
 150:	80 93 81 01 	sts	0x0181, r24
	stdout = stdin = uart_str;
 154:	90 93 90 01 	sts	0x0190, r25
 158:	80 93 8f 01 	sts	0x018F, r24
 15c:	90 93 92 01 	sts	0x0192, r25
 160:	80 93 91 01 	sts	0x0191, r24
 164:	08 95       	ret

00000166 <main>:
 * initialize the usart baud rate
 * @param baud_rate the baud rate for teh usart module
 */
void usart_set_baud_rate(unsigned long baud_rate){
	unsigned int ubrr = (F_CPU/16/baud_rate)-1;
	UBRR0H = (unsigned char)(ubrr>>8);
 166:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr;
 16a:	83 e3       	ldi	r24, 0x33	; 51
 16c:	80 93 c4 00 	sts	0x00C4, r24
 * @param stop_bits	0->1 stop bit, 1-> 2 stop bits
 * @param char_size	0->5-bit, 1->6-bit, 2->7-bit, 3->8-bit,7->9-bit
 * @param pol		0->tx or rising, rx on falling, 1-> tx on falling, rx on rising
 */
void usart_setup(uint8_t mode, uint8_t parity, uint8_t stop_bits, uint8_t char_size,uint8_t pol){
	 UCSR0C =  (mode<<6) | (parity<<4) | (stop_bits<<3) |(char_size<<1) | (pol<<0);
 170:	86 e0       	ldi	r24, 0x06	; 6
 172:	80 93 c2 00 	sts	0x00C2, r24

/**
 * enable the USART tx and rx
 */
void usart_enable(){
	 UCSR0B = (1<<RXEN0)|(1<<TXEN0);
 176:	88 e1       	ldi	r24, 0x18	; 24
 178:	80 93 c1 00 	sts	0x00C1, r24

	//UART
	usart_set_baud_rate(9600);
	usart_setup(0,0,0,3,0);
	usart_enable();
	stdio_serial_initialize();
 17c:	0e 94 a0 00 	call	0x140	; 0x140 <_Z23stdio_serial_initializev>
	
	printf("RF24/examples/GettingStarted\n");
 180:	8d e1       	ldi	r24, 0x1D	; 29
 182:	91 e0       	ldi	r25, 0x01	; 1
 184:	0e 94 74 04 	call	0x8e8	; 0x8e8 <puts>
	printf("*** PRESS 'T' to begin transmitting to the other node\n");
 188:	8a e3       	ldi	r24, 0x3A	; 58
 18a:	91 e0       	ldi	r25, 0x01	; 1
 18c:	0e 94 74 04 	call	0x8e8	; 0x8e8 <puts>
	return elapsed_us;
	//return 0;
}

inline void initialize_timer_0A(){
	TCCR0A |= (1<<WGM01) | (1<<WGM00); //fast pwm
 190:	84 b5       	in	r24, 0x24	; 36
 192:	83 60       	ori	r24, 0x03	; 3
 194:	84 bd       	out	0x24, r24	; 36
	//TCCR0B |= (1<<FOC0A) ;//force output compare match on channel A
	TCCR0B |= (1<<CS01) | (1<<CS00); // div by 64 , therefore , if 8MHz --> 1Mhz ....if 16 MHz --> 2 MHz
 196:	85 b5       	in	r24, 0x25	; 37
 198:	83 60       	ori	r24, 0x03	; 3
 19a:	85 bd       	out	0x25, r24	; 37
	
	//OCR0A = 4; //if 8 Mhz return 10 us on compare,  if 16 Mhz return 5 us on compare
	TIMSK0 |= (1<<TOIE0);
 19c:	ee e6       	ldi	r30, 0x6E	; 110
 19e:	f0 e0       	ldi	r31, 0x00	; 0
 1a0:	80 81       	ld	r24, Z
 1a2:	81 60       	ori	r24, 0x01	; 1
 1a4:	80 83       	st	Z, r24
	sei();
 1a6:	78 94       	sei

	initialize_timer_0A();

    radio.begin();
 1a8:	80 e7       	ldi	r24, 0x70	; 112
 1aa:	91 e0       	ldi	r25, 0x01	; 1
 1ac:	0e 94 c1 03 	call	0x782	; 0x782 <_ZN4RF245beginEv>
	//radio.setDataRate(RF24_250KBPS);
	radio.setPALevel(RF24_PA_LOW);
 1b0:	61 e0       	ldi	r22, 0x01	; 1
 1b2:	80 e7       	ldi	r24, 0x70	; 112
 1b4:	91 e0       	ldi	r25, 0x01	; 1
 1b6:	0e 94 67 03 	call	0x6ce	; 0x6ce <_ZN4RF2410setPALevelEh>
	
  // Open a writing and reading pipe on each radio, with opposite addresses
	if(radioNumber) {
 1ba:	80 91 80 01 	lds	r24, 0x0180
 1be:	88 23       	and	r24, r24
 1c0:	71 f0       	breq	.+28     	; 0x1de <main+0x78>
		radio.openWritingPipe(addresses[1]);
 1c2:	6c e0       	ldi	r22, 0x0C	; 12
 1c4:	71 e0       	ldi	r23, 0x01	; 1
 1c6:	80 e7       	ldi	r24, 0x70	; 112
 1c8:	91 e0       	ldi	r25, 0x01	; 1
 1ca:	0e 94 85 02 	call	0x50a	; 0x50a <_ZN4RF2415openWritingPipeEPKh>
		radio.openReadingPipe(1,addresses[0]);
 1ce:	46 e0       	ldi	r20, 0x06	; 6
 1d0:	51 e0       	ldi	r21, 0x01	; 1
 1d2:	61 e0       	ldi	r22, 0x01	; 1
 1d4:	80 e7       	ldi	r24, 0x70	; 112
 1d6:	91 e0       	ldi	r25, 0x01	; 1
 1d8:	0e 94 a0 02 	call	0x540	; 0x540 <_ZN4RF2415openReadingPipeEhPKh>
 1dc:	0d c0       	rjmp	.+26     	; 0x1f8 <main+0x92>
	}
	else {
		radio.openWritingPipe(addresses[0]);
 1de:	66 e0       	ldi	r22, 0x06	; 6
 1e0:	71 e0       	ldi	r23, 0x01	; 1
 1e2:	80 e7       	ldi	r24, 0x70	; 112
 1e4:	91 e0       	ldi	r25, 0x01	; 1
 1e6:	0e 94 85 02 	call	0x50a	; 0x50a <_ZN4RF2415openWritingPipeEPKh>
		radio.openReadingPipe(1,addresses[1]);
 1ea:	4c e0       	ldi	r20, 0x0C	; 12
 1ec:	51 e0       	ldi	r21, 0x01	; 1
 1ee:	61 e0       	ldi	r22, 0x01	; 1
 1f0:	80 e7       	ldi	r24, 0x70	; 112
 1f2:	91 e0       	ldi	r25, 0x01	; 1
 1f4:	0e 94 a0 02 	call	0x540	; 0x540 <_ZN4RF2415openReadingPipeEhPKh>
	}
    
    radio.startListening();
 1f8:	80 e7       	ldi	r24, 0x70	; 112
 1fa:	91 e0       	ldi	r25, 0x01	; 1
 1fc:	0e 94 12 03 	call	0x624	; 0x624 <_ZN4RF2414startListeningEv>
// 				radio.startListening();
// 				
// 			}
// 		}

		radio.ce(false);
 200:	60 e0       	ldi	r22, 0x00	; 0
 202:	80 e7       	ldi	r24, 0x70	; 112
 204:	91 e0       	ldi	r25, 0x01	; 1
 206:	0e 94 96 01 	call	0x32c	; 0x32c <_ZN4RF242ceEb>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 20a:	2f ef       	ldi	r18, 0xFF	; 255
 20c:	89 e6       	ldi	r24, 0x69	; 105
 20e:	98 e1       	ldi	r25, 0x18	; 24
 210:	21 50       	subi	r18, 0x01	; 1
 212:	80 40       	sbci	r24, 0x00	; 0
 214:	90 40       	sbci	r25, 0x00	; 0
 216:	e1 f7       	brne	.-8      	; 0x210 <main+0xaa>
 218:	00 c0       	rjmp	.+0      	; 0x21a <main+0xb4>
 21a:	00 00       	nop
		_delay_ms(1000);
		radio.ce(false);
 21c:	60 e0       	ldi	r22, 0x00	; 0
 21e:	80 e7       	ldi	r24, 0x70	; 112
 220:	91 e0       	ldi	r25, 0x01	; 1
 222:	0e 94 96 01 	call	0x32c	; 0x32c <_ZN4RF242ceEb>
 226:	2f ef       	ldi	r18, 0xFF	; 255
 228:	89 e6       	ldi	r24, 0x69	; 105
 22a:	98 e1       	ldi	r25, 0x18	; 24
 22c:	21 50       	subi	r18, 0x01	; 1
 22e:	80 40       	sbci	r24, 0x00	; 0
 230:	90 40       	sbci	r25, 0x00	; 0
 232:	e1 f7       	brne	.-8      	; 0x22c <main+0xc6>
 234:	00 c0       	rjmp	.+0      	; 0x236 <main+0xd0>
 236:	00 00       	nop
 238:	e3 cf       	rjmp	.-58     	; 0x200 <main+0x9a>

0000023a <_GLOBAL__sub_I__Z19usart_set_baud_ratem>:
/****************** User Config ***************************/
/***      Set this radio as radio number 0 or 1         ***/
bool radioNumber = 0;

/* Hardware configuration: Set up nRF24L01 radio on SPI bus plus pins 7 & 8 */
RF24 radio;
 23a:	80 e7       	ldi	r24, 0x70	; 112
 23c:	91 e0       	ldi	r25, 0x01	; 1
 23e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <_ZN4RF24C1Ev>
 242:	08 95       	ret

00000244 <__vector_16>:
volatile int us_counter = 0;
volatile int ms_counter = 0;
volatile int elapsed_us = 0;
volatile int elapsed_ms = 0;

ISR (TIMER0_OVF_vect){
 244:	1f 92       	push	r1
 246:	0f 92       	push	r0
 248:	0f b6       	in	r0, 0x3f	; 63
 24a:	0f 92       	push	r0
 24c:	11 24       	eor	r1, r1
 24e:	2f 93       	push	r18
 250:	8f 93       	push	r24
 252:	9f 93       	push	r25
	us_4++;
 254:	80 91 8b 01 	lds	r24, 0x018B
 258:	90 91 8c 01 	lds	r25, 0x018C
 25c:	01 96       	adiw	r24, 0x01	; 1
 25e:	90 93 8c 01 	sts	0x018C, r25
 262:	80 93 8b 01 	sts	0x018B, r24
	if(us_4>=250){  ////if 8 Mhz make it >100 ,  if 16 Mhz   make it  > 200
 266:	80 91 8b 01 	lds	r24, 0x018B
 26a:	90 91 8c 01 	lds	r25, 0x018C
 26e:	8a 3f       	cpi	r24, 0xFA	; 250
 270:	91 05       	cpc	r25, r1
 272:	0c f4       	brge	.+2      	; 0x276 <__vector_16+0x32>
 274:	43 c0       	rjmp	.+134    	; 0x2fc <__vector_16+0xb8>
		us_4 = 0;
 276:	10 92 8c 01 	sts	0x018C, r1
 27a:	10 92 8b 01 	sts	0x018B, r1
		us_counter++;
 27e:	80 91 89 01 	lds	r24, 0x0189
 282:	90 91 8a 01 	lds	r25, 0x018A
 286:	01 96       	adiw	r24, 0x01	; 1
 288:	90 93 8a 01 	sts	0x018A, r25
 28c:	80 93 89 01 	sts	0x0189, r24
		elapsed_us ++;  //increment the us
 290:	80 91 85 01 	lds	r24, 0x0185
 294:	90 91 86 01 	lds	r25, 0x0186
 298:	01 96       	adiw	r24, 0x01	; 1
 29a:	90 93 86 01 	sts	0x0186, r25
 29e:	80 93 85 01 	sts	0x0185, r24
		if(us_counter>1000){
 2a2:	80 91 89 01 	lds	r24, 0x0189
 2a6:	90 91 8a 01 	lds	r25, 0x018A
 2aa:	89 3e       	cpi	r24, 0xE9	; 233
 2ac:	93 40       	sbci	r25, 0x03	; 3
 2ae:	2c f1       	brlt	.+74     	; 0x2fa <__vector_16+0xb6>
			us_counter=0;
 2b0:	10 92 8a 01 	sts	0x018A, r1
 2b4:	10 92 89 01 	sts	0x0189, r1
			elapsed_ms++; //increment the ms
 2b8:	80 91 83 01 	lds	r24, 0x0183
 2bc:	90 91 84 01 	lds	r25, 0x0184
 2c0:	01 96       	adiw	r24, 0x01	; 1
 2c2:	90 93 84 01 	sts	0x0184, r25
 2c6:	80 93 83 01 	sts	0x0183, r24
			ms_counter++;
 2ca:	80 91 87 01 	lds	r24, 0x0187
 2ce:	90 91 88 01 	lds	r25, 0x0188
 2d2:	01 96       	adiw	r24, 0x01	; 1
 2d4:	90 93 88 01 	sts	0x0188, r25
 2d8:	80 93 87 01 	sts	0x0187, r24
			if(ms_counter>=1000)
 2dc:	80 91 87 01 	lds	r24, 0x0187
 2e0:	90 91 88 01 	lds	r25, 0x0188
 2e4:	88 3e       	cpi	r24, 0xE8	; 232
 2e6:	93 40       	sbci	r25, 0x03	; 3
 2e8:	44 f0       	brlt	.+16     	; 0x2fa <__vector_16+0xb6>
			{
				ms_counter = 0;
 2ea:	10 92 88 01 	sts	0x0188, r1
 2ee:	10 92 87 01 	sts	0x0187, r1
				PORTB^=1;
 2f2:	95 b1       	in	r25, 0x05	; 5
 2f4:	81 e0       	ldi	r24, 0x01	; 1
 2f6:	89 27       	eor	r24, r25
 2f8:	85 b9       	out	0x05, r24	; 5
			}
		}
		asm("nop");
 2fa:	00 00       	nop
	}
 2fc:	9f 91       	pop	r25
 2fe:	8f 91       	pop	r24
 300:	2f 91       	pop	r18
 302:	0f 90       	pop	r0
 304:	0f be       	out	0x3f, r0	; 63
 306:	0f 90       	pop	r0
 308:	1f 90       	pop	r1
 30a:	18 95       	reti

0000030c <_ZN4RF243csnEb>:
	  _SPI.setDataMode(RF24_DATA_MODE);
	  _SPI.setClockDivider(spi_speed ? spi_speed : RF24_CLOCK_DIVIDER);
	  _SPI.chipSelect(csn_pin);
	  delayMicroseconds(5);
#elif defined (__AVR__) 
	  if (mode == HIGH) {
 30c:	66 23       	and	r22, r22
 30e:	41 f0       	breq	.+16     	; 0x320 <_ZN4RF243csnEb+0x14>
		  CSN_PORT |= (1<<CSN_BIT);  	// SCK->CSN HIGH
 310:	28 9a       	sbi	0x05, 0	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 312:	87 ec       	ldi	r24, 0xC7	; 199
 314:	90 e0       	ldi	r25, 0x00	; 0
 316:	01 97       	sbiw	r24, 0x01	; 1
 318:	f1 f7       	brne	.-4      	; 0x316 <_ZN4RF243csnEb+0xa>
 31a:	00 c0       	rjmp	.+0      	; 0x31c <_ZN4RF243csnEb+0x10>
 31c:	00 00       	nop
 31e:	08 95       	ret
		  delayMicroseconds(100); // allow csn to settle.
	  }
	  else {
		  CSN_PORT &= ~(1<<CSN_BIT);	// SCK->CSN LOW
 320:	28 98       	cbi	0x05, 0	; 5
 322:	9d e1       	ldi	r25, 0x1D	; 29
 324:	9a 95       	dec	r25
 326:	f1 f7       	brne	.-4      	; 0x324 <_ZN4RF243csnEb+0x18>
 328:	00 00       	nop
 32a:	08 95       	ret

0000032c <_ZN4RF242ceEb>:
/****************************************************************************/
int mode;
void RF24::ce(bool level)
{
	#if defined(__AVR__)
	if (ce_pin != csn_pin){
 32c:	fc 01       	movw	r30, r24
 32e:	20 81       	ld	r18, Z
 330:	81 81       	ldd	r24, Z+1	; 0x01
 332:	28 17       	cp	r18, r24
 334:	99 f0       	breq	.+38     	; 0x35c <_ZN4RF242ceEb+0x30>
		if (mode == HIGH) {
 336:	80 91 8d 01 	lds	r24, 0x018D
 33a:	90 91 8e 01 	lds	r25, 0x018E
 33e:	01 97       	sbiw	r24, 0x01	; 1
 340:	41 f4       	brne	.+16     	; 0x352 <_ZN4RF242ceEb+0x26>
			CE_PORT |= (1<<CE_BIT);  	// SCK->CSN HIGH
 342:	5f 9a       	sbi	0x0b, 7	; 11
 344:	87 ec       	ldi	r24, 0xC7	; 199
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	01 97       	sbiw	r24, 0x01	; 1
 34a:	f1 f7       	brne	.-4      	; 0x348 <_ZN4RF242ceEb+0x1c>
 34c:	00 c0       	rjmp	.+0      	; 0x34e <_ZN4RF242ceEb+0x22>
 34e:	00 00       	nop
 350:	08 95       	ret
			delayMicroseconds(100); // allow csn to settle.
		}
		else {
			CE_PORT &= ~(1<<CE_BIT);	// SCK->CSN LOW
 352:	5f 98       	cbi	0x0b, 7	; 11
 354:	9d e1       	ldi	r25, 0x1D	; 29
 356:	9a 95       	dec	r25
 358:	f1 f7       	brne	.-4      	; 0x356 <_ZN4RF242ceEb+0x2a>
 35a:	00 00       	nop
 35c:	08 95       	ret

0000035e <_ZN4RF2413read_registerEh>:
}

/****************************************************************************/

uint8_t RF24::read_register(uint8_t reg)
{
 35e:	1f 93       	push	r17
 360:	cf 93       	push	r28
 362:	df 93       	push	r29
 364:	ec 01       	movw	r28, r24
 366:	16 2f       	mov	r17, r22
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 368:	84 b1       	in	r24, 0x04	; 4
 36a:	8c 62       	ori	r24, 0x2C	; 44
 36c:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 36e:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 370:	8c b5       	in	r24, 0x2c	; 44
 372:	80 65       	ori	r24, 0x50	; 80
 374:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 376:	60 e0       	ldi	r22, 0x00	; 0
 378:	ce 01       	movw	r24, r28
 37a:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
  _SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, 2);
  result = *++prx;   // result is 2nd byte of receive buffer  

	#elif defined(__AVR__)
	beginTransaction();
	AVR_SPI_MSTR_TRANSMIT_VAL( R_REGISTER | ( REGISTER_MASK & reg ) );
 37e:	1f 71       	andi	r17, 0x1F	; 31
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 380:	1e bd       	out	0x2e, r17	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 382:	0d b4       	in	r0, 0x2d	; 45
 384:	07 fe       	sbrs	r0, 7
 386:	fd cf       	rjmp	.-6      	; 0x382 <_ZN4RF2413read_registerEh+0x24>
	return SPDR;
 388:	8e b5       	in	r24, 0x2e	; 46
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 38a:	8f ef       	ldi	r24, 0xFF	; 255
 38c:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 38e:	0d b4       	in	r0, 0x2d	; 45
 390:	07 fe       	sbrs	r0, 7
 392:	fd cf       	rjmp	.-6      	; 0x38e <_ZN4RF2413read_registerEh+0x30>
	return SPDR;
 394:	1e b5       	in	r17, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 396:	61 e0       	ldi	r22, 0x01	; 1
 398:	ce 01       	movw	r24, r28
 39a:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return result;
}
 39e:	81 2f       	mov	r24, r17
 3a0:	df 91       	pop	r29
 3a2:	cf 91       	pop	r28
 3a4:	1f 91       	pop	r17
 3a6:	08 95       	ret

000003a8 <_ZN4RF2414write_registerEhPKhh>:

/****************************************************************************/

uint8_t RF24::write_register(uint8_t reg, const uint8_t* buf, uint8_t len)
{
 3a8:	ef 92       	push	r14
 3aa:	ff 92       	push	r15
 3ac:	0f 93       	push	r16
 3ae:	1f 93       	push	r17
 3b0:	cf 93       	push	r28
 3b2:	df 93       	push	r29
 3b4:	ec 01       	movw	r28, r24
 3b6:	06 2f       	mov	r16, r22
 3b8:	e4 2e       	mov	r14, r20
 3ba:	f5 2e       	mov	r15, r21
 3bc:	12 2f       	mov	r17, r18
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 3be:	84 b1       	in	r24, 0x04	; 4
 3c0:	8c 62       	ori	r24, 0x2C	; 44
 3c2:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 3c4:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 3c6:	8c b5       	in	r24, 0x2c	; 44
 3c8:	80 65       	ori	r24, 0x50	; 80
 3ca:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 3cc:	60 e0       	ldi	r22, 0x00	; 0
 3ce:	ce 01       	movw	r24, r28
 3d0:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
  _SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, size);
  status = *prx; // status is 1st byte of receive buffer

  	#elif defined(__AVR__)
  	 beginTransaction();
  	 status = AVR_SPI_MSTR_TRANSMIT_VAL( W_REGISTER | ( REGISTER_MASK & reg ) );
 3d4:	0f 71       	andi	r16, 0x1F	; 31
 3d6:	00 62       	ori	r16, 0x20	; 32
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 3d8:	0e bd       	out	0x2e, r16	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 3da:	0d b4       	in	r0, 0x2d	; 45
 3dc:	07 fe       	sbrs	r0, 7
 3de:	fd cf       	rjmp	.-6      	; 0x3da <_ZN4RF2414write_registerEhPKhh+0x32>
	return SPDR;
 3e0:	0e b5       	in	r16, 0x2e	; 46
  	 while ( len-- )
 3e2:	9f ef       	ldi	r25, 0xFF	; 255
 3e4:	91 0f       	add	r25, r17
 3e6:	11 23       	and	r17, r17
 3e8:	51 f0       	breq	.+20     	; 0x3fe <_ZN4RF2414write_registerEhPKhh+0x56>
 3ea:	ee 2d       	mov	r30, r14
 3ec:	ff 2d       	mov	r31, r15
  	 AVR_SPI_MSTR_TRANSMIT_VAL(*buf++);
 3ee:	21 91       	ld	r18, Z+
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 3f0:	2e bd       	out	0x2e, r18	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 3f2:	0d b4       	in	r0, 0x2d	; 45
 3f4:	07 fe       	sbrs	r0, 7
 3f6:	fd cf       	rjmp	.-6      	; 0x3f2 <_ZN4RF2414write_registerEhPKhh+0x4a>
	return SPDR;
 3f8:	2e b5       	in	r18, 0x2e	; 46
  status = *prx; // status is 1st byte of receive buffer

  	#elif defined(__AVR__)
  	 beginTransaction();
  	 status = AVR_SPI_MSTR_TRANSMIT_VAL( W_REGISTER | ( REGISTER_MASK & reg ) );
  	 while ( len-- )
 3fa:	91 50       	subi	r25, 0x01	; 1
 3fc:	c0 f7       	brcc	.-16     	; 0x3ee <_ZN4RF2414write_registerEhPKhh+0x46>
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 3fe:	61 e0       	ldi	r22, 0x01	; 1
 400:	ce 01       	movw	r24, r28
 402:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return status;
}
 406:	80 2f       	mov	r24, r16
 408:	df 91       	pop	r29
 40a:	cf 91       	pop	r28
 40c:	1f 91       	pop	r17
 40e:	0f 91       	pop	r16
 410:	ff 90       	pop	r15
 412:	ef 90       	pop	r14
 414:	08 95       	ret

00000416 <_ZN4RF2414write_registerEhh>:

/****************************************************************************/

uint8_t RF24::write_register(uint8_t reg, uint8_t value)
{
 416:	0f 93       	push	r16
 418:	1f 93       	push	r17
 41a:	cf 93       	push	r28
 41c:	df 93       	push	r29
 41e:	ec 01       	movw	r28, r24
 420:	16 2f       	mov	r17, r22
 422:	04 2f       	mov	r16, r20
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 424:	84 b1       	in	r24, 0x04	; 4
 426:	8c 62       	ori	r24, 0x2C	; 44
 428:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 42a:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 42c:	8c b5       	in	r24, 0x2c	; 44
 42e:	80 65       	ori	r24, 0x50	; 80
 430:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 432:	60 e0       	ldi	r22, 0x00	; 0
 434:	ce 01       	movw	r24, r28
 436:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
	_SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, 2);
	status = *prx++; // status is 1st byte of receive buffer

	#elif defined(__AVR__)
	beginTransaction();
	status = AVR_SPI_MSTR_TRANSMIT_VAL( W_REGISTER | ( REGISTER_MASK & reg ) );
 43a:	1f 71       	andi	r17, 0x1F	; 31
 43c:	10 62       	ori	r17, 0x20	; 32
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 43e:	1e bd       	out	0x2e, r17	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 440:	0d b4       	in	r0, 0x2d	; 45
 442:	07 fe       	sbrs	r0, 7
 444:	fd cf       	rjmp	.-6      	; 0x440 <_ZN4RF2414write_registerEhh+0x2a>
	return SPDR;
 446:	1e b5       	in	r17, 0x2e	; 46
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 448:	0e bd       	out	0x2e, r16	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 44a:	0d b4       	in	r0, 0x2d	; 45
 44c:	07 fe       	sbrs	r0, 7
 44e:	fd cf       	rjmp	.-6      	; 0x44a <_ZN4RF2414write_registerEhh+0x34>
	return SPDR;
 450:	8e b5       	in	r24, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 452:	61 e0       	ldi	r22, 0x01	; 1
 454:	ce 01       	movw	r24, r28
 456:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return status;
}
 45a:	81 2f       	mov	r24, r17
 45c:	df 91       	pop	r29
 45e:	cf 91       	pop	r28
 460:	1f 91       	pop	r17
 462:	0f 91       	pop	r16
 464:	08 95       	ret

00000466 <_ZN4RF248spiTransEh>:
  return spiTrans( FLUSH_TX );
}

/****************************************************************************/

uint8_t RF24::spiTrans(uint8_t cmd){
 466:	1f 93       	push	r17
 468:	cf 93       	push	r28
 46a:	df 93       	push	r29
 46c:	ec 01       	movw	r28, r24
 46e:	16 2f       	mov	r17, r22
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 470:	84 b1       	in	r24, 0x04	; 4
 472:	8c 62       	ori	r24, 0x2C	; 44
 474:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 476:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 478:	8c b5       	in	r24, 0x2c	; 44
 47a:	80 65       	ori	r24, 0x50	; 80
 47c:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 47e:	60 e0       	ldi	r22, 0x00	; 0
 480:	ce 01       	movw	r24, r28
 482:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 486:	1e bd       	out	0x2e, r17	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 488:	0d b4       	in	r0, 0x2d	; 45
 48a:	07 fe       	sbrs	r0, 7
 48c:	fd cf       	rjmp	.-6      	; 0x488 <_ZN4RF248spiTransEh+0x22>
	return SPDR;
 48e:	1e b5       	in	r17, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 490:	61 e0       	ldi	r22, 0x01	; 1
 492:	ce 01       	movw	r24, r28
 494:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
  endTransaction();

  #endif

  return status;
}
 498:	81 2f       	mov	r24, r17
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	1f 91       	pop	r17
 4a0:	08 95       	ret

000004a2 <_ZN4RF248flush_rxEv>:

/****************************************************************************/

uint8_t RF24::flush_rx(void)
{
  return spiTrans( FLUSH_RX );
 4a2:	62 ee       	ldi	r22, 0xE2	; 226
 4a4:	0e 94 33 02 	call	0x466	; 0x466 <_ZN4RF248spiTransEh>
}
 4a8:	08 95       	ret

000004aa <_ZN4RF248flush_txEv>:

/****************************************************************************/

uint8_t RF24::flush_tx(void)
{
  return spiTrans( FLUSH_TX );
 4aa:	61 ee       	ldi	r22, 0xE1	; 225
 4ac:	0e 94 33 02 	call	0x466	; 0x466 <_ZN4RF248spiTransEh>
}
 4b0:	08 95       	ret

000004b2 <_ZN4RF24C1Ev>:
  printf_P(PSTR("\r\n"));
}
#endif
/****************************************************************************/

RF24::RF24():p_variant(false),
 4b2:	fc 01       	movw	r30, r24
payload_size(32), dynamic_payloads_enabled(false), addr_width(5)
 4b4:	12 82       	std	Z+2, r1	; 0x02
 4b6:	80 e2       	ldi	r24, 0x20	; 32
 4b8:	83 83       	std	Z+3, r24	; 0x03
 4ba:	14 82       	std	Z+4, r1	; 0x04
 4bc:	85 e0       	ldi	r24, 0x05	; 5
 4be:	82 87       	std	Z+10, r24	; 0x0a
{
	pipe0_reading_address[0]=0;
 4c0:	15 82       	std	Z+5, r1	; 0x05
 4c2:	08 95       	ret

000004c4 <_ZN4RF2410setChannelEh>:
#endif

/****************************************************************************/

void RF24::setChannel(uint8_t channel)
{
 4c4:	46 2f       	mov	r20, r22
  const uint8_t max_channel = 127;
  write_register(RF_CH,rf24_min(channel,max_channel));
 4c6:	60 38       	cpi	r22, 0x80	; 128
 4c8:	08 f0       	brcs	.+2      	; 0x4cc <_ZN4RF2410setChannelEh+0x8>
 4ca:	4f e7       	ldi	r20, 0x7F	; 127
 4cc:	65 e0       	ldi	r22, 0x05	; 5
 4ce:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
 4d2:	08 95       	ret

000004d4 <_ZN4RF247powerUpEv>:

/****************************************************************************/

//Power up now. Radio will not power down unless instructed by MCU for config changes etc.
void RF24::powerUp(void)
{
 4d4:	cf 93       	push	r28
 4d6:	df 93       	push	r29
 4d8:	ec 01       	movw	r28, r24
   uint8_t cfg = read_register(CONFIG);
 4da:	60 e0       	ldi	r22, 0x00	; 0
 4dc:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>

   // if not powered up then power up and wait for the radio to initialize
   if (!(cfg & _BV(PWR_UP))){
 4e0:	81 fd       	sbrc	r24, 1
 4e2:	10 c0       	rjmp	.+32     	; 0x504 <_ZN4RF247powerUpEv+0x30>
      write_register(CONFIG,read_register(CONFIG) | _BV(PWR_UP));
 4e4:	60 e0       	ldi	r22, 0x00	; 0
 4e6:	ce 01       	movw	r24, r28
 4e8:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 4ec:	48 2f       	mov	r20, r24
 4ee:	42 60       	ori	r20, 0x02	; 2
 4f0:	60 e0       	ldi	r22, 0x00	; 0
 4f2:	ce 01       	movw	r24, r28
 4f4:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4f8:	8f e0       	ldi	r24, 0x0F	; 15
 4fa:	97 e2       	ldi	r25, 0x27	; 39
 4fc:	01 97       	sbiw	r24, 0x01	; 1
 4fe:	f1 f7       	brne	.-4      	; 0x4fc <_ZN4RF247powerUpEv+0x28>
 500:	00 c0       	rjmp	.+0      	; 0x502 <_ZN4RF247powerUpEv+0x2e>
 502:	00 00       	nop
	  _delay_ms(5);
	  #else
      delay(5);
	  #endif
   }
}
 504:	df 91       	pop	r29
 506:	cf 91       	pop	r28
 508:	08 95       	ret

0000050a <_ZN4RF2415openWritingPipeEPKh>:
  write_register(RX_PW_P0,payload_size);
}

/****************************************************************************/
void RF24::openWritingPipe(const uint8_t *address)
{
 50a:	0f 93       	push	r16
 50c:	1f 93       	push	r17
 50e:	cf 93       	push	r28
 510:	df 93       	push	r29
 512:	ec 01       	movw	r28, r24
 514:	8b 01       	movw	r16, r22
  // Note that AVR 8-bit uC's store this LSB first, and the NRF24L01(+)
  // expects it LSB first too, so we're good.

  write_register(RX_ADDR_P0,address, addr_width);
 516:	2a 85       	ldd	r18, Y+10	; 0x0a
 518:	ab 01       	movw	r20, r22
 51a:	6a e0       	ldi	r22, 0x0A	; 10
 51c:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <_ZN4RF2414write_registerEhPKhh>
  write_register(TX_ADDR, address, addr_width);
 520:	2a 85       	ldd	r18, Y+10	; 0x0a
 522:	a8 01       	movw	r20, r16
 524:	60 e1       	ldi	r22, 0x10	; 16
 526:	ce 01       	movw	r24, r28
 528:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <_ZN4RF2414write_registerEhPKhh>

  //const uint8_t max_payload_size = 32;
  //write_register(RX_PW_P0,rf24_min(payload_size,max_payload_size));
  write_register(RX_PW_P0,payload_size);
 52c:	4b 81       	ldd	r20, Y+3	; 0x03
 52e:	61 e1       	ldi	r22, 0x11	; 17
 530:	ce 01       	movw	r24, r28
 532:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
}
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	1f 91       	pop	r17
 53c:	0f 91       	pop	r16
 53e:	08 95       	ret

00000540 <_ZN4RF2415openReadingPipeEhPKh>:
}

/****************************************************************************/

void RF24::openReadingPipe(uint8_t child, const uint8_t *address)
{
 540:	ff 92       	push	r15
 542:	0f 93       	push	r16
 544:	1f 93       	push	r17
 546:	cf 93       	push	r28
 548:	df 93       	push	r29
 54a:	ec 01       	movw	r28, r24
 54c:	f6 2e       	mov	r15, r22
 54e:	8a 01       	movw	r16, r20
  // If this is pipe 0, cache the address.  This is needed because
  // openWritingPipe() will overwrite the pipe 0 address, so
  // startListening() will have to restore it.
  if (child == 0){
 550:	61 11       	cpse	r22, r1
 552:	07 c0       	rjmp	.+14     	; 0x562 <_ZN4RF2415openReadingPipeEhPKh+0x22>
    memcpy(pipe0_reading_address,address,addr_width);
 554:	4a 85       	ldd	r20, Y+10	; 0x0a
 556:	50 e0       	ldi	r21, 0x00	; 0
 558:	b8 01       	movw	r22, r16
 55a:	05 96       	adiw	r24, 0x05	; 5
 55c:	0e 94 20 04 	call	0x840	; 0x840 <memcpy>
 560:	07 c0       	rjmp	.+14     	; 0x570 <_ZN4RF2415openReadingPipeEhPKh+0x30>
  }
  if (child <= 6)
 562:	66 e0       	ldi	r22, 0x06	; 6
 564:	6f 15       	cp	r22, r15
 566:	08 f4       	brcc	.+2      	; 0x56a <_ZN4RF2415openReadingPipeEhPKh+0x2a>
 568:	36 c0       	rjmp	.+108    	; 0x5d6 <_ZN4RF2415openReadingPipeEhPKh+0x96>
  {
    // For pipes 2-5, only write the LSB
    if ( child < 2 ){
 56a:	71 e0       	ldi	r23, 0x01	; 1
 56c:	7f 15       	cp	r23, r15
 56e:	58 f0       	brcs	.+22     	; 0x586 <_ZN4RF2415openReadingPipeEhPKh+0x46>
      write_register(pgm_read_byte(&child_pipe[child]), address, addr_width);
 570:	ef 2d       	mov	r30, r15
 572:	f0 e0       	ldi	r31, 0x00	; 0
 574:	e2 59       	subi	r30, 0x92	; 146
 576:	ff 4f       	sbci	r31, 0xFF	; 255
 578:	64 91       	lpm	r22, Z
 57a:	2a 85       	ldd	r18, Y+10	; 0x0a
 57c:	a8 01       	movw	r20, r16
 57e:	ce 01       	movw	r24, r28
 580:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <_ZN4RF2414write_registerEhPKhh>
 584:	08 c0       	rjmp	.+16     	; 0x596 <_ZN4RF2415openReadingPipeEhPKh+0x56>
    }else{
      write_register(pgm_read_byte(&child_pipe[child]), address, 1);
 586:	ef 2d       	mov	r30, r15
 588:	f0 e0       	ldi	r31, 0x00	; 0
 58a:	e2 59       	subi	r30, 0x92	; 146
 58c:	ff 4f       	sbci	r31, 0xFF	; 255
 58e:	64 91       	lpm	r22, Z
 590:	21 e0       	ldi	r18, 0x01	; 1
 592:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <_ZN4RF2414write_registerEhPKhh>
	}
    write_register(pgm_read_byte(&child_payload_size[child]),payload_size);
 596:	0f 2d       	mov	r16, r15
 598:	10 e0       	ldi	r17, 0x00	; 0
 59a:	f8 01       	movw	r30, r16
 59c:	e8 59       	subi	r30, 0x98	; 152
 59e:	ff 4f       	sbci	r31, 0xFF	; 255
 5a0:	64 91       	lpm	r22, Z
 5a2:	4b 81       	ldd	r20, Y+3	; 0x03
 5a4:	ce 01       	movw	r24, r28
 5a6:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>

    // Note it would be more efficient to set all of the bits for all open
    // pipes at once.  However, I thought it would make the calling code
    // more simple to do it this way.
    write_register(EN_RXADDR,read_register(EN_RXADDR) | _BV(pgm_read_byte(&child_pipe_enable[child])));
 5aa:	62 e0       	ldi	r22, 0x02	; 2
 5ac:	ce 01       	movw	r24, r28
 5ae:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 5b2:	f8 01       	movw	r30, r16
 5b4:	ec 58       	subi	r30, 0x8C	; 140
 5b6:	ff 4f       	sbci	r31, 0xFF	; 255
 5b8:	44 91       	lpm	r20, Z
 5ba:	21 e0       	ldi	r18, 0x01	; 1
 5bc:	30 e0       	ldi	r19, 0x00	; 0
 5be:	b9 01       	movw	r22, r18
 5c0:	02 c0       	rjmp	.+4      	; 0x5c6 <_ZN4RF2415openReadingPipeEhPKh+0x86>
 5c2:	66 0f       	add	r22, r22
 5c4:	77 1f       	adc	r23, r23
 5c6:	4a 95       	dec	r20
 5c8:	e2 f7       	brpl	.-8      	; 0x5c2 <_ZN4RF2415openReadingPipeEhPKh+0x82>
 5ca:	ab 01       	movw	r20, r22
 5cc:	48 2b       	or	r20, r24
 5ce:	62 e0       	ldi	r22, 0x02	; 2
 5d0:	ce 01       	movw	r24, r28
 5d2:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>

  }
}
 5d6:	df 91       	pop	r29
 5d8:	cf 91       	pop	r28
 5da:	1f 91       	pop	r17
 5dc:	0f 91       	pop	r16
 5de:	ff 90       	pop	r15
 5e0:	08 95       	ret

000005e2 <_ZN4RF2416closeReadingPipeEh>:

/****************************************************************************/

void RF24::closeReadingPipe( uint8_t pipe )
{
 5e2:	1f 93       	push	r17
 5e4:	cf 93       	push	r28
 5e6:	df 93       	push	r29
 5e8:	ec 01       	movw	r28, r24
 5ea:	16 2f       	mov	r17, r22
  write_register(EN_RXADDR,read_register(EN_RXADDR) & ~_BV(pgm_read_byte(&child_pipe_enable[pipe])));
 5ec:	62 e0       	ldi	r22, 0x02	; 2
 5ee:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 5f2:	e1 2f       	mov	r30, r17
 5f4:	f0 e0       	ldi	r31, 0x00	; 0
 5f6:	ec 58       	subi	r30, 0x8C	; 140
 5f8:	ff 4f       	sbci	r31, 0xFF	; 255
 5fa:	e4 91       	lpm	r30, Z
 5fc:	21 e0       	ldi	r18, 0x01	; 1
 5fe:	30 e0       	ldi	r19, 0x00	; 0
 600:	a9 01       	movw	r20, r18
 602:	02 c0       	rjmp	.+4      	; 0x608 <_ZN4RF2416closeReadingPipeEh+0x26>
 604:	44 0f       	add	r20, r20
 606:	55 1f       	adc	r21, r21
 608:	ea 95       	dec	r30
 60a:	e2 f7       	brpl	.-8      	; 0x604 <_ZN4RF2416closeReadingPipeEh+0x22>
 60c:	fa 01       	movw	r30, r20
 60e:	e0 95       	com	r30
 610:	4e 2f       	mov	r20, r30
 612:	48 23       	and	r20, r24
 614:	62 e0       	ldi	r22, 0x02	; 2
 616:	ce 01       	movw	r24, r28
 618:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
}
 61c:	df 91       	pop	r29
 61e:	cf 91       	pop	r28
 620:	1f 91       	pop	r17
 622:	08 95       	ret

00000624 <_ZN4RF2414startListeningEv>:
}

/****************************************************************************/

void RF24::startListening(void)
{
 624:	cf 93       	push	r28
 626:	df 93       	push	r29
 628:	ec 01       	movw	r28, r24
 #if !defined (RF24_TINY) && ! defined(LITTLEWIRE)
  powerUp();
 62a:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <_ZN4RF247powerUpEv>
 #endif
  write_register(CONFIG, read_register(CONFIG) | _BV(PRIM_RX));
 62e:	60 e0       	ldi	r22, 0x00	; 0
 630:	ce 01       	movw	r24, r28
 632:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 636:	48 2f       	mov	r20, r24
 638:	41 60       	ori	r20, 0x01	; 1
 63a:	60 e0       	ldi	r22, 0x00	; 0
 63c:	ce 01       	movw	r24, r28
 63e:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
  write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT) );
 642:	40 e7       	ldi	r20, 0x70	; 112
 644:	67 e0       	ldi	r22, 0x07	; 7
 646:	ce 01       	movw	r24, r28
 648:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
  ce(HIGH);
 64c:	61 e0       	ldi	r22, 0x01	; 1
 64e:	ce 01       	movw	r24, r28
 650:	0e 94 96 01 	call	0x32c	; 0x32c <_ZN4RF242ceEb>
  // Restore the pipe0 adddress, if exists
  if (pipe0_reading_address[0] > 0){
 654:	8d 81       	ldd	r24, Y+5	; 0x05
 656:	88 23       	and	r24, r24
 658:	49 f0       	breq	.+18     	; 0x66c <_ZN4RF2414startListeningEv+0x48>
    write_register(RX_ADDR_P0, pipe0_reading_address, addr_width);	
 65a:	2a 85       	ldd	r18, Y+10	; 0x0a
 65c:	ae 01       	movw	r20, r28
 65e:	4b 5f       	subi	r20, 0xFB	; 251
 660:	5f 4f       	sbci	r21, 0xFF	; 255
 662:	6a e0       	ldi	r22, 0x0A	; 10
 664:	ce 01       	movw	r24, r28
 666:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <_ZN4RF2414write_registerEhPKhh>
 66a:	04 c0       	rjmp	.+8      	; 0x674 <_ZN4RF2414startListeningEv+0x50>
  }else{
	closeReadingPipe(0);
 66c:	60 e0       	ldi	r22, 0x00	; 0
 66e:	ce 01       	movw	r24, r28
 670:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <_ZN4RF2416closeReadingPipeEh>
  }

  // Flush buffers
  //flush_rx();
  if(read_register(FEATURE) & _BV(EN_ACK_PAY)){
 674:	6d e1       	ldi	r22, 0x1D	; 29
 676:	ce 01       	movw	r24, r28
 678:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 67c:	81 ff       	sbrs	r24, 1
 67e:	03 c0       	rjmp	.+6      	; 0x686 <_ZN4RF2414startListeningEv+0x62>
	flush_tx();
 680:	ce 01       	movw	r24, r28
 682:	0e 94 55 02 	call	0x4aa	; 0x4aa <_ZN4RF248flush_txEv>
  }

  // Go!
  //delayMicroseconds(100);
}
 686:	df 91       	pop	r29
 688:	cf 91       	pop	r28
 68a:	08 95       	ret

0000068c <_ZN4RF2415toggle_featuresEv>:
}

/****************************************************************************/

void RF24::toggle_features(void)
{
 68c:	cf 93       	push	r28
 68e:	df 93       	push	r29
 690:	ec 01       	movw	r28, r24
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 692:	84 b1       	in	r24, 0x04	; 4
 694:	8c 62       	ori	r24, 0x2C	; 44
 696:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 698:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 69a:	8c b5       	in	r24, 0x2c	; 44
 69c:	80 65       	ori	r24, 0x50	; 80
 69e:	8c bd       	out	0x2c, r24	; 44
    #if defined (RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF_SPI_SPEED, MSBFIRST, SPI_MODE0));
	#elif defined (__AVR__)
	AVR_SPI_MSTR_INIT(); 
	#endif
    csn(LOW);
 6a0:	60 e0       	ldi	r22, 0x00	; 0
 6a2:	ce 01       	movw	r24, r28
 6a4:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 6a8:	80 e5       	ldi	r24, 0x50	; 80
 6aa:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 6ac:	0d b4       	in	r0, 0x2d	; 45
 6ae:	07 fe       	sbrs	r0, 7
 6b0:	fd cf       	rjmp	.-6      	; 0x6ac <_ZN4RF2415toggle_featuresEv+0x20>
	return SPDR;
 6b2:	8e b5       	in	r24, 0x2e	; 46
 * @param data value of data byte to be sent
 * return data sent back from the salve
 */
inline uint8_t spi_master_transmit_byte_val(uint8_t data){
	//fill SPDR with data to write
	SPDR = data;
 6b4:	83 e7       	ldi	r24, 0x73	; 115
 6b6:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
 6b8:	0d b4       	in	r0, 0x2d	; 45
 6ba:	07 fe       	sbrs	r0, 7
 6bc:	fd cf       	rjmp	.-6      	; 0x6b8 <_ZN4RF2415toggle_featuresEv+0x2c>
	return SPDR;
 6be:	8e b5       	in	r24, 0x2e	; 46
  }

/****************************************************************************/

  inline void RF24::endTransaction() {
    csn(HIGH);
 6c0:	61 e0       	ldi	r22, 0x01	; 1
 6c2:	ce 01       	movw	r24, r28
 6c4:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
	_SPI.transfer( ACTIVATE );
    _SPI.transfer( 0x73 );
	endTransaction();
  #endif

}
 6c8:	df 91       	pop	r29
 6ca:	cf 91       	pop	r28
 6cc:	08 95       	ret

000006ce <_ZN4RF2410setPALevelEh>:
}

/****************************************************************************/

void RF24::setPALevel(uint8_t level)
{
 6ce:	1f 93       	push	r17
 6d0:	cf 93       	push	r28
 6d2:	df 93       	push	r29
 6d4:	ec 01       	movw	r28, r24
 6d6:	16 2f       	mov	r17, r22

  uint8_t setup = read_register(RF_SETUP) & 0b11111000;
 6d8:	66 e0       	ldi	r22, 0x06	; 6
 6da:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 6de:	88 7f       	andi	r24, 0xF8	; 248

  if(level > 3){  						// If invalid level, go to max PA
 6e0:	14 30       	cpi	r17, 0x04	; 4
 6e2:	20 f4       	brcc	.+8      	; 0x6ec <_ZN4RF2410setPALevelEh+0x1e>
	  level = (RF24_PA_MAX << 1) + 1;		// +1 to support the SI24R1 chip extra bit
  }else{
	  level = (level << 1) + 1;	 		// Else set level as requested
 6e4:	41 2f       	mov	r20, r17
 6e6:	44 0f       	add	r20, r20
 6e8:	4f 5f       	subi	r20, 0xFF	; 255
 6ea:	01 c0       	rjmp	.+2      	; 0x6ee <_ZN4RF2410setPALevelEh+0x20>
{

  uint8_t setup = read_register(RF_SETUP) & 0b11111000;

  if(level > 3){  						// If invalid level, go to max PA
	  level = (RF24_PA_MAX << 1) + 1;		// +1 to support the SI24R1 chip extra bit
 6ec:	47 e0       	ldi	r20, 0x07	; 7
  }else{
	  level = (level << 1) + 1;	 		// Else set level as requested
  }


  write_register( RF_SETUP, setup |= level ) ;	// Write it to the chip
 6ee:	48 2b       	or	r20, r24
 6f0:	66 e0       	ldi	r22, 0x06	; 6
 6f2:	ce 01       	movw	r24, r28
 6f4:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
}
 6f8:	df 91       	pop	r29
 6fa:	cf 91       	pop	r28
 6fc:	1f 91       	pop	r17
 6fe:	08 95       	ret

00000700 <_ZN4RF2411setDataRateE15rf24_datarate_e>:
}

/****************************************************************************/

bool RF24::setDataRate(rf24_datarate_e speed)
{
 700:	ff 92       	push	r15
 702:	0f 93       	push	r16
 704:	1f 93       	push	r17
 706:	cf 93       	push	r28
 708:	df 93       	push	r29
 70a:	ec 01       	movw	r28, r24
 70c:	16 2f       	mov	r17, r22
  bool result = false;
  uint8_t setup = read_register(RF_SETUP) ;
 70e:	66 e0       	ldi	r22, 0x06	; 6
 710:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>

  // HIGH and LOW '00' is 1Mbs - our default
  setup &= ~(_BV(RF_DR_LOW) | _BV(RF_DR_HIGH)) ;
 714:	87 7d       	andi	r24, 0xD7	; 215
 716:	f8 2e       	mov	r15, r24
  #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
    txRxDelay=250;
  #else //16Mhz Arduino
    txRxDelay=85;
  #endif
  if( speed == RF24_250KBPS )
 718:	12 30       	cpi	r17, 0x02	; 2
 71a:	59 f4       	brne	.+22     	; 0x732 <_ZN4RF2411setDataRateE15rf24_datarate_e+0x32>
  {
    // Must set the RF_DR_LOW to 1; RF_DR_HIGH (used to be RF_DR) is already 0
    // Making it '10'.
    setup |= _BV( RF_DR_LOW ) ;
 71c:	80 62       	ori	r24, 0x20	; 32
 71e:	f8 2e       	mov	r15, r24
  #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
    txRxDelay=450;
  #else //16Mhz Arduino
	txRxDelay=155;
 720:	0b e9       	ldi	r16, 0x9B	; 155
 722:	10 e0       	ldi	r17, 0x00	; 0
 724:	20 e0       	ldi	r18, 0x00	; 0
 726:	30 e0       	ldi	r19, 0x00	; 0
 728:	0b 87       	std	Y+11, r16	; 0x0b
 72a:	1c 87       	std	Y+12, r17	; 0x0c
 72c:	2d 87       	std	Y+13, r18	; 0x0d
 72e:	3e 87       	std	Y+14, r19	; 0x0e
 730:	15 c0       	rjmp	.+42     	; 0x75c <_ZN4RF2411setDataRateE15rf24_datarate_e+0x5c>
  }
  else
  {
    // Set 2Mbs, RF_DR (RF_DR_HIGH) is set 1
    // Making it '01'
    if ( speed == RF24_2MBPS )
 732:	11 30       	cpi	r17, 0x01	; 1
 734:	49 f0       	breq	.+18     	; 0x748 <_ZN4RF2411setDataRateE15rf24_datarate_e+0x48>
  setup &= ~(_BV(RF_DR_LOW) | _BV(RF_DR_HIGH)) ;
  
  #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
    txRxDelay=250;
  #else //16Mhz Arduino
    txRxDelay=85;
 736:	05 e5       	ldi	r16, 0x55	; 85
 738:	10 e0       	ldi	r17, 0x00	; 0
 73a:	20 e0       	ldi	r18, 0x00	; 0
 73c:	30 e0       	ldi	r19, 0x00	; 0
 73e:	0b 87       	std	Y+11, r16	; 0x0b
 740:	1c 87       	std	Y+12, r17	; 0x0c
 742:	2d 87       	std	Y+13, r18	; 0x0d
 744:	3e 87       	std	Y+14, r19	; 0x0e
 746:	0a c0       	rjmp	.+20     	; 0x75c <_ZN4RF2411setDataRateE15rf24_datarate_e+0x5c>
  {
    // Set 2Mbs, RF_DR (RF_DR_HIGH) is set 1
    // Making it '01'
    if ( speed == RF24_2MBPS )
    {
      setup |= _BV(RF_DR_HIGH);
 748:	88 60       	ori	r24, 0x08	; 8
 74a:	f8 2e       	mov	r15, r24
      #if defined(__arm__) || defined (RF24_LINUX) || defined (__ARDUINO_X86__)
      txRxDelay=190;
      #else //16Mhz Arduino	  
	  txRxDelay=65;
 74c:	01 e4       	ldi	r16, 0x41	; 65
 74e:	10 e0       	ldi	r17, 0x00	; 0
 750:	20 e0       	ldi	r18, 0x00	; 0
 752:	30 e0       	ldi	r19, 0x00	; 0
 754:	0b 87       	std	Y+11, r16	; 0x0b
 756:	1c 87       	std	Y+12, r17	; 0x0c
 758:	2d 87       	std	Y+13, r18	; 0x0d
 75a:	3e 87       	std	Y+14, r19	; 0x0e
	  #endif
    }
  }
  write_register(RF_SETUP,setup);
 75c:	4f 2d       	mov	r20, r15
 75e:	66 e0       	ldi	r22, 0x06	; 6
 760:	ce 01       	movw	r24, r28
 762:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>

  // Verify our result
  if ( read_register(RF_SETUP) == setup )
 766:	66 e0       	ldi	r22, 0x06	; 6
 768:	ce 01       	movw	r24, r28
 76a:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 76e:	91 e0       	ldi	r25, 0x01	; 1
 770:	f8 12       	cpse	r15, r24
 772:	90 e0       	ldi	r25, 0x00	; 0
  {
    result = true;
  }
  return result;
}
 774:	89 2f       	mov	r24, r25
 776:	df 91       	pop	r29
 778:	cf 91       	pop	r28
 77a:	1f 91       	pop	r17
 77c:	0f 91       	pop	r16
 77e:	ff 90       	pop	r15
 780:	08 95       	ret

00000782 <_ZN4RF245beginEv>:

#endif
/****************************************************************************/

bool RF24::begin(void)
{
 782:	cf 93       	push	r28
 784:	df 93       	push	r29
 786:	ec 01       	movw	r28, r24
  #elif defined(LITTLEWIRE)
    pinMode(csn_pin,OUTPUT);
    _SPI.begin();
    csn(HIGH);
  #elif defined(__AVR__)
	CE_DDR |= (1<<CE_BIT);
 788:	57 9a       	sbi	0x0a, 7	; 10
	CSN_DDR|=(1<<CSN_BIT);
 78a:	20 9a       	sbi	0x04, 0	; 4
/**
 * initialize the SPI module as master
 */
inline void spi_master_initialize(){
	//set !SS,MOSI,SCK pin as output pins
	SPI_DDR |= (1<<PINB2) | (1<<MOSI_BIT) | (1<<SCK_BIT);
 78c:	84 b1       	in	r24, 0x04	; 4
 78e:	8c 62       	ori	r24, 0x2C	; 44
 790:	84 b9       	out	0x04, r24	; 4
	//set MISO as input pin
	SPI_DDR &= ~(1<<MISO_BIT);
 792:	24 98       	cbi	0x04, 4	; 4
	//enable SPI and set as master
	SPCR |= (1<<SPE) | (1<<MSTR);
 794:	8c b5       	in	r24, 0x2c	; 44
 796:	80 65       	ori	r24, 0x50	; 80
 798:	8c bd       	out	0x2c, r24	; 44
	spi_master_initialize();
	csn(HIGH);
 79a:	61 e0       	ldi	r22, 0x01	; 1
 79c:	ce 01       	movw	r24, r28
 79e:	0e 94 86 01 	call	0x30c	; 0x30c <_ZN4RF243csnEb>
 7a2:	8f e0       	ldi	r24, 0x0F	; 15
 7a4:	97 e2       	ldi	r25, 0x27	; 39
 7a6:	01 97       	sbiw	r24, 0x01	; 1
 7a8:	f1 f7       	brne	.-4      	; 0x7a6 <_ZN4RF245beginEv+0x24>
 7aa:	00 c0       	rjmp	.+0      	; 0x7ac <_ZN4RF245beginEv+0x2a>
 7ac:	00 00       	nop
  #else
  delay( 5 ) ;
  #endif

  // Reset CONFIG and enable 16-bit CRC.
  write_register( CONFIG, 0b00001100 ) ;
 7ae:	4c e0       	ldi	r20, 0x0C	; 12
 7b0:	60 e0       	ldi	r22, 0x00	; 0
 7b2:	ce 01       	movw	r24, r28
 7b4:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
}

/****************************************************************************/
void RF24::setRetries(uint8_t delay, uint8_t count)
{
 write_register(SETUP_RETR,(delay&0xf)<<ARD | (count&0xf)<<ARC);
 7b8:	4f e5       	ldi	r20, 0x5F	; 95
 7ba:	64 e0       	ldi	r22, 0x04	; 4
 7bc:	ce 01       	movw	r24, r28
 7be:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
  // Reset value is MAX
  //setPALevel( RF24_PA_MAX ) ;

  // check for connected module and if this is a p nRF24l01 variant
  //
  if( setDataRate( RF24_250KBPS ) )
 7c2:	62 e0       	ldi	r22, 0x02	; 2
 7c4:	ce 01       	movw	r24, r28
 7c6:	0e 94 80 03 	call	0x700	; 0x700 <_ZN4RF2411setDataRateE15rf24_datarate_e>
 7ca:	88 23       	and	r24, r24
 7cc:	11 f0       	breq	.+4      	; 0x7d2 <_ZN4RF245beginEv+0x50>
  {
    p_variant = true ;
 7ce:	81 e0       	ldi	r24, 0x01	; 1
 7d0:	8a 83       	std	Y+2, r24	; 0x02
    p_variant = true ;
  }*/
  
  // Then set the data rate to the slowest (and most reliable) speed supported by all
  // hardware.
  setDataRate( RF24_1MBPS ) ;
 7d2:	60 e0       	ldi	r22, 0x00	; 0
 7d4:	ce 01       	movw	r24, r28
 7d6:	0e 94 80 03 	call	0x700	; 0x700 <_ZN4RF2411setDataRateE15rf24_datarate_e>

  // Initialize CRC and request 2-byte (16bit) CRC
  //setCRCLength( RF24_CRC_16 ) ;

  // Disable dynamic payloads, to match dynamic_payloads_enabled setting - Reset value is 0
  toggle_features();
 7da:	ce 01       	movw	r24, r28
 7dc:	0e 94 46 03 	call	0x68c	; 0x68c <_ZN4RF2415toggle_featuresEv>
  write_register(FEATURE,0 );
 7e0:	40 e0       	ldi	r20, 0x00	; 0
 7e2:	6d e1       	ldi	r22, 0x1D	; 29
 7e4:	ce 01       	movw	r24, r28
 7e6:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>
  write_register(DYNPD,0);
 7ea:	40 e0       	ldi	r20, 0x00	; 0
 7ec:	6c e1       	ldi	r22, 0x1C	; 28
 7ee:	ce 01       	movw	r24, r28
 7f0:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>

  // Reset current status
  // Notice reset and flush is the last thing we do
  write_register(NRF_STATUS,_BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT) );
 7f4:	40 e7       	ldi	r20, 0x70	; 112
 7f6:	67 e0       	ldi	r22, 0x07	; 7
 7f8:	ce 01       	movw	r24, r28
 7fa:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>

  // Set up default configuration.  Callers can always change it later.
  // This channel should be universally safe and not bleed over into adjacent
  // spectrum.
  setChannel(76);
 7fe:	6c e4       	ldi	r22, 0x4C	; 76
 800:	ce 01       	movw	r24, r28
 802:	0e 94 62 02 	call	0x4c4	; 0x4c4 <_ZN4RF2410setChannelEh>

  // Flush buffers
  flush_rx();
 806:	ce 01       	movw	r24, r28
 808:	0e 94 51 02 	call	0x4a2	; 0x4a2 <_ZN4RF248flush_rxEv>
  flush_tx();
 80c:	ce 01       	movw	r24, r28
 80e:	0e 94 55 02 	call	0x4aa	; 0x4aa <_ZN4RF248flush_txEv>

  powerUp(); //Power up by default when begin() is called
 812:	ce 01       	movw	r24, r28
 814:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <_ZN4RF247powerUpEv>

  // Enable PTX, do not write CE high so radio will remain in standby I mode ( 130us max to transition to RX or TX instead of 1500us from powerUp )
  // PTX should use only 22uA of power
  write_register(CONFIG, ( read_register(CONFIG) ) & ~_BV(PRIM_RX) );
 818:	60 e0       	ldi	r22, 0x00	; 0
 81a:	ce 01       	movw	r24, r28
 81c:	0e 94 af 01 	call	0x35e	; 0x35e <_ZN4RF2413read_registerEh>
 820:	48 2f       	mov	r20, r24
 822:	4e 7f       	andi	r20, 0xFE	; 254
 824:	60 e0       	ldi	r22, 0x00	; 0
 826:	ce 01       	movw	r24, r28
 828:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN4RF2414write_registerEhh>

  // if setup is 0 or ff then there was no response from module
  return ( setup != 0 && setup != 0xff );
}
 82c:	80 e0       	ldi	r24, 0x00	; 0
 82e:	df 91       	pop	r29
 830:	cf 91       	pop	r28
 832:	08 95       	ret

00000834 <__tablejump2__>:
 834:	ee 0f       	add	r30, r30
 836:	ff 1f       	adc	r31, r31

00000838 <__tablejump__>:
 838:	05 90       	lpm	r0, Z+
 83a:	f4 91       	lpm	r31, Z
 83c:	e0 2d       	mov	r30, r0
 83e:	09 94       	ijmp

00000840 <memcpy>:
 840:	fb 01       	movw	r30, r22
 842:	dc 01       	movw	r26, r24
 844:	02 c0       	rjmp	.+4      	; 0x84a <memcpy+0xa>
 846:	01 90       	ld	r0, Z+
 848:	0d 92       	st	X+, r0
 84a:	41 50       	subi	r20, 0x01	; 1
 84c:	50 40       	sbci	r21, 0x00	; 0
 84e:	d8 f7       	brcc	.-10     	; 0x846 <memcpy+0x6>
 850:	08 95       	ret

00000852 <fdevopen>:
 852:	0f 93       	push	r16
 854:	1f 93       	push	r17
 856:	cf 93       	push	r28
 858:	df 93       	push	r29
 85a:	ec 01       	movw	r28, r24
 85c:	8b 01       	movw	r16, r22
 85e:	00 97       	sbiw	r24, 0x00	; 0
 860:	31 f4       	brne	.+12     	; 0x86e <fdevopen+0x1c>
 862:	61 15       	cp	r22, r1
 864:	71 05       	cpc	r23, r1
 866:	19 f4       	brne	.+6      	; 0x86e <fdevopen+0x1c>
 868:	80 e0       	ldi	r24, 0x00	; 0
 86a:	90 e0       	ldi	r25, 0x00	; 0
 86c:	38 c0       	rjmp	.+112    	; 0x8de <fdevopen+0x8c>
 86e:	6e e0       	ldi	r22, 0x0E	; 14
 870:	70 e0       	ldi	r23, 0x00	; 0
 872:	81 e0       	ldi	r24, 0x01	; 1
 874:	90 e0       	ldi	r25, 0x00	; 0
 876:	0e 94 a1 04 	call	0x942	; 0x942 <calloc>
 87a:	fc 01       	movw	r30, r24
 87c:	00 97       	sbiw	r24, 0x00	; 0
 87e:	a1 f3       	breq	.-24     	; 0x868 <fdevopen+0x16>
 880:	80 e8       	ldi	r24, 0x80	; 128
 882:	83 83       	std	Z+3, r24	; 0x03
 884:	01 15       	cp	r16, r1
 886:	11 05       	cpc	r17, r1
 888:	71 f0       	breq	.+28     	; 0x8a6 <fdevopen+0x54>
 88a:	13 87       	std	Z+11, r17	; 0x0b
 88c:	02 87       	std	Z+10, r16	; 0x0a
 88e:	81 e8       	ldi	r24, 0x81	; 129
 890:	83 83       	std	Z+3, r24	; 0x03
 892:	80 91 8f 01 	lds	r24, 0x018F
 896:	90 91 90 01 	lds	r25, 0x0190
 89a:	89 2b       	or	r24, r25
 89c:	21 f4       	brne	.+8      	; 0x8a6 <fdevopen+0x54>
 89e:	f0 93 90 01 	sts	0x0190, r31
 8a2:	e0 93 8f 01 	sts	0x018F, r30
 8a6:	20 97       	sbiw	r28, 0x00	; 0
 8a8:	c9 f0       	breq	.+50     	; 0x8dc <fdevopen+0x8a>
 8aa:	d1 87       	std	Z+9, r29	; 0x09
 8ac:	c0 87       	std	Z+8, r28	; 0x08
 8ae:	83 81       	ldd	r24, Z+3	; 0x03
 8b0:	82 60       	ori	r24, 0x02	; 2
 8b2:	83 83       	std	Z+3, r24	; 0x03
 8b4:	80 91 91 01 	lds	r24, 0x0191
 8b8:	90 91 92 01 	lds	r25, 0x0192
 8bc:	89 2b       	or	r24, r25
 8be:	71 f4       	brne	.+28     	; 0x8dc <fdevopen+0x8a>
 8c0:	f0 93 92 01 	sts	0x0192, r31
 8c4:	e0 93 91 01 	sts	0x0191, r30
 8c8:	80 91 93 01 	lds	r24, 0x0193
 8cc:	90 91 94 01 	lds	r25, 0x0194
 8d0:	89 2b       	or	r24, r25
 8d2:	21 f4       	brne	.+8      	; 0x8dc <fdevopen+0x8a>
 8d4:	f0 93 94 01 	sts	0x0194, r31
 8d8:	e0 93 93 01 	sts	0x0193, r30
 8dc:	cf 01       	movw	r24, r30
 8de:	df 91       	pop	r29
 8e0:	cf 91       	pop	r28
 8e2:	1f 91       	pop	r17
 8e4:	0f 91       	pop	r16
 8e6:	08 95       	ret

000008e8 <puts>:
 8e8:	0f 93       	push	r16
 8ea:	1f 93       	push	r17
 8ec:	cf 93       	push	r28
 8ee:	df 93       	push	r29
 8f0:	e0 91 91 01 	lds	r30, 0x0191
 8f4:	f0 91 92 01 	lds	r31, 0x0192
 8f8:	23 81       	ldd	r18, Z+3	; 0x03
 8fa:	21 ff       	sbrs	r18, 1
 8fc:	1b c0       	rjmp	.+54     	; 0x934 <__stack+0x35>
 8fe:	ec 01       	movw	r28, r24
 900:	00 e0       	ldi	r16, 0x00	; 0
 902:	10 e0       	ldi	r17, 0x00	; 0
 904:	89 91       	ld	r24, Y+
 906:	60 91 91 01 	lds	r22, 0x0191
 90a:	70 91 92 01 	lds	r23, 0x0192
 90e:	db 01       	movw	r26, r22
 910:	18 96       	adiw	r26, 0x08	; 8
 912:	ed 91       	ld	r30, X+
 914:	fc 91       	ld	r31, X
 916:	19 97       	sbiw	r26, 0x09	; 9
 918:	88 23       	and	r24, r24
 91a:	31 f0       	breq	.+12     	; 0x928 <__stack+0x29>
 91c:	09 95       	icall
 91e:	89 2b       	or	r24, r25
 920:	89 f3       	breq	.-30     	; 0x904 <__stack+0x5>
 922:	0f ef       	ldi	r16, 0xFF	; 255
 924:	1f ef       	ldi	r17, 0xFF	; 255
 926:	ee cf       	rjmp	.-36     	; 0x904 <__stack+0x5>
 928:	8a e0       	ldi	r24, 0x0A	; 10
 92a:	09 95       	icall
 92c:	89 2b       	or	r24, r25
 92e:	11 f4       	brne	.+4      	; 0x934 <__stack+0x35>
 930:	c8 01       	movw	r24, r16
 932:	02 c0       	rjmp	.+4      	; 0x938 <__stack+0x39>
 934:	8f ef       	ldi	r24, 0xFF	; 255
 936:	9f ef       	ldi	r25, 0xFF	; 255
 938:	df 91       	pop	r29
 93a:	cf 91       	pop	r28
 93c:	1f 91       	pop	r17
 93e:	0f 91       	pop	r16
 940:	08 95       	ret

00000942 <calloc>:
 942:	0f 93       	push	r16
 944:	1f 93       	push	r17
 946:	cf 93       	push	r28
 948:	df 93       	push	r29
 94a:	86 9f       	mul	r24, r22
 94c:	80 01       	movw	r16, r0
 94e:	87 9f       	mul	r24, r23
 950:	10 0d       	add	r17, r0
 952:	96 9f       	mul	r25, r22
 954:	10 0d       	add	r17, r0
 956:	11 24       	eor	r1, r1
 958:	c8 01       	movw	r24, r16
 95a:	0e 94 bd 04 	call	0x97a	; 0x97a <malloc>
 95e:	ec 01       	movw	r28, r24
 960:	00 97       	sbiw	r24, 0x00	; 0
 962:	29 f0       	breq	.+10     	; 0x96e <calloc+0x2c>
 964:	a8 01       	movw	r20, r16
 966:	60 e0       	ldi	r22, 0x00	; 0
 968:	70 e0       	ldi	r23, 0x00	; 0
 96a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <memset>
 96e:	ce 01       	movw	r24, r28
 970:	df 91       	pop	r29
 972:	cf 91       	pop	r28
 974:	1f 91       	pop	r17
 976:	0f 91       	pop	r16
 978:	08 95       	ret

0000097a <malloc>:
 97a:	cf 93       	push	r28
 97c:	df 93       	push	r29
 97e:	82 30       	cpi	r24, 0x02	; 2
 980:	91 05       	cpc	r25, r1
 982:	10 f4       	brcc	.+4      	; 0x988 <malloc+0xe>
 984:	82 e0       	ldi	r24, 0x02	; 2
 986:	90 e0       	ldi	r25, 0x00	; 0
 988:	e0 91 97 01 	lds	r30, 0x0197
 98c:	f0 91 98 01 	lds	r31, 0x0198
 990:	20 e0       	ldi	r18, 0x00	; 0
 992:	30 e0       	ldi	r19, 0x00	; 0
 994:	a0 e0       	ldi	r26, 0x00	; 0
 996:	b0 e0       	ldi	r27, 0x00	; 0
 998:	30 97       	sbiw	r30, 0x00	; 0
 99a:	39 f1       	breq	.+78     	; 0x9ea <malloc+0x70>
 99c:	40 81       	ld	r20, Z
 99e:	51 81       	ldd	r21, Z+1	; 0x01
 9a0:	48 17       	cp	r20, r24
 9a2:	59 07       	cpc	r21, r25
 9a4:	b8 f0       	brcs	.+46     	; 0x9d4 <malloc+0x5a>
 9a6:	48 17       	cp	r20, r24
 9a8:	59 07       	cpc	r21, r25
 9aa:	71 f4       	brne	.+28     	; 0x9c8 <malloc+0x4e>
 9ac:	82 81       	ldd	r24, Z+2	; 0x02
 9ae:	93 81       	ldd	r25, Z+3	; 0x03
 9b0:	10 97       	sbiw	r26, 0x00	; 0
 9b2:	29 f0       	breq	.+10     	; 0x9be <malloc+0x44>
 9b4:	13 96       	adiw	r26, 0x03	; 3
 9b6:	9c 93       	st	X, r25
 9b8:	8e 93       	st	-X, r24
 9ba:	12 97       	sbiw	r26, 0x02	; 2
 9bc:	2c c0       	rjmp	.+88     	; 0xa16 <malloc+0x9c>
 9be:	90 93 98 01 	sts	0x0198, r25
 9c2:	80 93 97 01 	sts	0x0197, r24
 9c6:	27 c0       	rjmp	.+78     	; 0xa16 <malloc+0x9c>
 9c8:	21 15       	cp	r18, r1
 9ca:	31 05       	cpc	r19, r1
 9cc:	31 f0       	breq	.+12     	; 0x9da <malloc+0x60>
 9ce:	42 17       	cp	r20, r18
 9d0:	53 07       	cpc	r21, r19
 9d2:	18 f0       	brcs	.+6      	; 0x9da <malloc+0x60>
 9d4:	a9 01       	movw	r20, r18
 9d6:	db 01       	movw	r26, r22
 9d8:	01 c0       	rjmp	.+2      	; 0x9dc <malloc+0x62>
 9da:	ef 01       	movw	r28, r30
 9dc:	9a 01       	movw	r18, r20
 9de:	bd 01       	movw	r22, r26
 9e0:	df 01       	movw	r26, r30
 9e2:	02 80       	ldd	r0, Z+2	; 0x02
 9e4:	f3 81       	ldd	r31, Z+3	; 0x03
 9e6:	e0 2d       	mov	r30, r0
 9e8:	d7 cf       	rjmp	.-82     	; 0x998 <malloc+0x1e>
 9ea:	21 15       	cp	r18, r1
 9ec:	31 05       	cpc	r19, r1
 9ee:	f9 f0       	breq	.+62     	; 0xa2e <malloc+0xb4>
 9f0:	28 1b       	sub	r18, r24
 9f2:	39 0b       	sbc	r19, r25
 9f4:	24 30       	cpi	r18, 0x04	; 4
 9f6:	31 05       	cpc	r19, r1
 9f8:	80 f4       	brcc	.+32     	; 0xa1a <malloc+0xa0>
 9fa:	8a 81       	ldd	r24, Y+2	; 0x02
 9fc:	9b 81       	ldd	r25, Y+3	; 0x03
 9fe:	61 15       	cp	r22, r1
 a00:	71 05       	cpc	r23, r1
 a02:	21 f0       	breq	.+8      	; 0xa0c <malloc+0x92>
 a04:	fb 01       	movw	r30, r22
 a06:	93 83       	std	Z+3, r25	; 0x03
 a08:	82 83       	std	Z+2, r24	; 0x02
 a0a:	04 c0       	rjmp	.+8      	; 0xa14 <malloc+0x9a>
 a0c:	90 93 98 01 	sts	0x0198, r25
 a10:	80 93 97 01 	sts	0x0197, r24
 a14:	fe 01       	movw	r30, r28
 a16:	32 96       	adiw	r30, 0x02	; 2
 a18:	44 c0       	rjmp	.+136    	; 0xaa2 <malloc+0x128>
 a1a:	fe 01       	movw	r30, r28
 a1c:	e2 0f       	add	r30, r18
 a1e:	f3 1f       	adc	r31, r19
 a20:	81 93       	st	Z+, r24
 a22:	91 93       	st	Z+, r25
 a24:	22 50       	subi	r18, 0x02	; 2
 a26:	31 09       	sbc	r19, r1
 a28:	39 83       	std	Y+1, r19	; 0x01
 a2a:	28 83       	st	Y, r18
 a2c:	3a c0       	rjmp	.+116    	; 0xaa2 <malloc+0x128>
 a2e:	20 91 95 01 	lds	r18, 0x0195
 a32:	30 91 96 01 	lds	r19, 0x0196
 a36:	23 2b       	or	r18, r19
 a38:	41 f4       	brne	.+16     	; 0xa4a <malloc+0xd0>
 a3a:	20 91 02 01 	lds	r18, 0x0102
 a3e:	30 91 03 01 	lds	r19, 0x0103
 a42:	30 93 96 01 	sts	0x0196, r19
 a46:	20 93 95 01 	sts	0x0195, r18
 a4a:	20 91 00 01 	lds	r18, 0x0100
 a4e:	30 91 01 01 	lds	r19, 0x0101
 a52:	21 15       	cp	r18, r1
 a54:	31 05       	cpc	r19, r1
 a56:	41 f4       	brne	.+16     	; 0xa68 <malloc+0xee>
 a58:	2d b7       	in	r18, 0x3d	; 61
 a5a:	3e b7       	in	r19, 0x3e	; 62
 a5c:	40 91 04 01 	lds	r20, 0x0104
 a60:	50 91 05 01 	lds	r21, 0x0105
 a64:	24 1b       	sub	r18, r20
 a66:	35 0b       	sbc	r19, r21
 a68:	e0 91 95 01 	lds	r30, 0x0195
 a6c:	f0 91 96 01 	lds	r31, 0x0196
 a70:	e2 17       	cp	r30, r18
 a72:	f3 07       	cpc	r31, r19
 a74:	a0 f4       	brcc	.+40     	; 0xa9e <malloc+0x124>
 a76:	2e 1b       	sub	r18, r30
 a78:	3f 0b       	sbc	r19, r31
 a7a:	28 17       	cp	r18, r24
 a7c:	39 07       	cpc	r19, r25
 a7e:	78 f0       	brcs	.+30     	; 0xa9e <malloc+0x124>
 a80:	ac 01       	movw	r20, r24
 a82:	4e 5f       	subi	r20, 0xFE	; 254
 a84:	5f 4f       	sbci	r21, 0xFF	; 255
 a86:	24 17       	cp	r18, r20
 a88:	35 07       	cpc	r19, r21
 a8a:	48 f0       	brcs	.+18     	; 0xa9e <malloc+0x124>
 a8c:	4e 0f       	add	r20, r30
 a8e:	5f 1f       	adc	r21, r31
 a90:	50 93 96 01 	sts	0x0196, r21
 a94:	40 93 95 01 	sts	0x0195, r20
 a98:	81 93       	st	Z+, r24
 a9a:	91 93       	st	Z+, r25
 a9c:	02 c0       	rjmp	.+4      	; 0xaa2 <malloc+0x128>
 a9e:	e0 e0       	ldi	r30, 0x00	; 0
 aa0:	f0 e0       	ldi	r31, 0x00	; 0
 aa2:	cf 01       	movw	r24, r30
 aa4:	df 91       	pop	r29
 aa6:	cf 91       	pop	r28
 aa8:	08 95       	ret

00000aaa <free>:
 aaa:	cf 93       	push	r28
 aac:	df 93       	push	r29
 aae:	00 97       	sbiw	r24, 0x00	; 0
 ab0:	09 f4       	brne	.+2      	; 0xab4 <free+0xa>
 ab2:	87 c0       	rjmp	.+270    	; 0xbc2 <free+0x118>
 ab4:	fc 01       	movw	r30, r24
 ab6:	32 97       	sbiw	r30, 0x02	; 2
 ab8:	13 82       	std	Z+3, r1	; 0x03
 aba:	12 82       	std	Z+2, r1	; 0x02
 abc:	c0 91 97 01 	lds	r28, 0x0197
 ac0:	d0 91 98 01 	lds	r29, 0x0198
 ac4:	20 97       	sbiw	r28, 0x00	; 0
 ac6:	81 f4       	brne	.+32     	; 0xae8 <free+0x3e>
 ac8:	20 81       	ld	r18, Z
 aca:	31 81       	ldd	r19, Z+1	; 0x01
 acc:	28 0f       	add	r18, r24
 ace:	39 1f       	adc	r19, r25
 ad0:	80 91 95 01 	lds	r24, 0x0195
 ad4:	90 91 96 01 	lds	r25, 0x0196
 ad8:	82 17       	cp	r24, r18
 ada:	93 07       	cpc	r25, r19
 adc:	79 f5       	brne	.+94     	; 0xb3c <free+0x92>
 ade:	f0 93 96 01 	sts	0x0196, r31
 ae2:	e0 93 95 01 	sts	0x0195, r30
 ae6:	6d c0       	rjmp	.+218    	; 0xbc2 <free+0x118>
 ae8:	de 01       	movw	r26, r28
 aea:	20 e0       	ldi	r18, 0x00	; 0
 aec:	30 e0       	ldi	r19, 0x00	; 0
 aee:	ae 17       	cp	r26, r30
 af0:	bf 07       	cpc	r27, r31
 af2:	50 f4       	brcc	.+20     	; 0xb08 <free+0x5e>
 af4:	12 96       	adiw	r26, 0x02	; 2
 af6:	4d 91       	ld	r20, X+
 af8:	5c 91       	ld	r21, X
 afa:	13 97       	sbiw	r26, 0x03	; 3
 afc:	9d 01       	movw	r18, r26
 afe:	41 15       	cp	r20, r1
 b00:	51 05       	cpc	r21, r1
 b02:	09 f1       	breq	.+66     	; 0xb46 <free+0x9c>
 b04:	da 01       	movw	r26, r20
 b06:	f3 cf       	rjmp	.-26     	; 0xaee <free+0x44>
 b08:	b3 83       	std	Z+3, r27	; 0x03
 b0a:	a2 83       	std	Z+2, r26	; 0x02
 b0c:	40 81       	ld	r20, Z
 b0e:	51 81       	ldd	r21, Z+1	; 0x01
 b10:	84 0f       	add	r24, r20
 b12:	95 1f       	adc	r25, r21
 b14:	8a 17       	cp	r24, r26
 b16:	9b 07       	cpc	r25, r27
 b18:	71 f4       	brne	.+28     	; 0xb36 <free+0x8c>
 b1a:	8d 91       	ld	r24, X+
 b1c:	9c 91       	ld	r25, X
 b1e:	11 97       	sbiw	r26, 0x01	; 1
 b20:	84 0f       	add	r24, r20
 b22:	95 1f       	adc	r25, r21
 b24:	02 96       	adiw	r24, 0x02	; 2
 b26:	91 83       	std	Z+1, r25	; 0x01
 b28:	80 83       	st	Z, r24
 b2a:	12 96       	adiw	r26, 0x02	; 2
 b2c:	8d 91       	ld	r24, X+
 b2e:	9c 91       	ld	r25, X
 b30:	13 97       	sbiw	r26, 0x03	; 3
 b32:	93 83       	std	Z+3, r25	; 0x03
 b34:	82 83       	std	Z+2, r24	; 0x02
 b36:	21 15       	cp	r18, r1
 b38:	31 05       	cpc	r19, r1
 b3a:	29 f4       	brne	.+10     	; 0xb46 <free+0x9c>
 b3c:	f0 93 98 01 	sts	0x0198, r31
 b40:	e0 93 97 01 	sts	0x0197, r30
 b44:	3e c0       	rjmp	.+124    	; 0xbc2 <free+0x118>
 b46:	d9 01       	movw	r26, r18
 b48:	13 96       	adiw	r26, 0x03	; 3
 b4a:	fc 93       	st	X, r31
 b4c:	ee 93       	st	-X, r30
 b4e:	12 97       	sbiw	r26, 0x02	; 2
 b50:	4d 91       	ld	r20, X+
 b52:	5d 91       	ld	r21, X+
 b54:	a4 0f       	add	r26, r20
 b56:	b5 1f       	adc	r27, r21
 b58:	ea 17       	cp	r30, r26
 b5a:	fb 07       	cpc	r31, r27
 b5c:	79 f4       	brne	.+30     	; 0xb7c <free+0xd2>
 b5e:	80 81       	ld	r24, Z
 b60:	91 81       	ldd	r25, Z+1	; 0x01
 b62:	84 0f       	add	r24, r20
 b64:	95 1f       	adc	r25, r21
 b66:	02 96       	adiw	r24, 0x02	; 2
 b68:	d9 01       	movw	r26, r18
 b6a:	11 96       	adiw	r26, 0x01	; 1
 b6c:	9c 93       	st	X, r25
 b6e:	8e 93       	st	-X, r24
 b70:	82 81       	ldd	r24, Z+2	; 0x02
 b72:	93 81       	ldd	r25, Z+3	; 0x03
 b74:	13 96       	adiw	r26, 0x03	; 3
 b76:	9c 93       	st	X, r25
 b78:	8e 93       	st	-X, r24
 b7a:	12 97       	sbiw	r26, 0x02	; 2
 b7c:	e0 e0       	ldi	r30, 0x00	; 0
 b7e:	f0 e0       	ldi	r31, 0x00	; 0
 b80:	8a 81       	ldd	r24, Y+2	; 0x02
 b82:	9b 81       	ldd	r25, Y+3	; 0x03
 b84:	00 97       	sbiw	r24, 0x00	; 0
 b86:	19 f0       	breq	.+6      	; 0xb8e <free+0xe4>
 b88:	fe 01       	movw	r30, r28
 b8a:	ec 01       	movw	r28, r24
 b8c:	f9 cf       	rjmp	.-14     	; 0xb80 <free+0xd6>
 b8e:	ce 01       	movw	r24, r28
 b90:	02 96       	adiw	r24, 0x02	; 2
 b92:	28 81       	ld	r18, Y
 b94:	39 81       	ldd	r19, Y+1	; 0x01
 b96:	82 0f       	add	r24, r18
 b98:	93 1f       	adc	r25, r19
 b9a:	20 91 95 01 	lds	r18, 0x0195
 b9e:	30 91 96 01 	lds	r19, 0x0196
 ba2:	28 17       	cp	r18, r24
 ba4:	39 07       	cpc	r19, r25
 ba6:	69 f4       	brne	.+26     	; 0xbc2 <free+0x118>
 ba8:	30 97       	sbiw	r30, 0x00	; 0
 baa:	29 f4       	brne	.+10     	; 0xbb6 <free+0x10c>
 bac:	10 92 98 01 	sts	0x0198, r1
 bb0:	10 92 97 01 	sts	0x0197, r1
 bb4:	02 c0       	rjmp	.+4      	; 0xbba <free+0x110>
 bb6:	13 82       	std	Z+3, r1	; 0x03
 bb8:	12 82       	std	Z+2, r1	; 0x02
 bba:	d0 93 96 01 	sts	0x0196, r29
 bbe:	c0 93 95 01 	sts	0x0195, r28
 bc2:	df 91       	pop	r29
 bc4:	cf 91       	pop	r28
 bc6:	08 95       	ret

00000bc8 <memset>:
 bc8:	dc 01       	movw	r26, r24
 bca:	01 c0       	rjmp	.+2      	; 0xbce <memset+0x6>
 bcc:	6d 93       	st	X+, r22
 bce:	41 50       	subi	r20, 0x01	; 1
 bd0:	50 40       	sbci	r21, 0x00	; 0
 bd2:	e0 f7       	brcc	.-8      	; 0xbcc <memset+0x4>
 bd4:	08 95       	ret

00000bd6 <_exit>:
 bd6:	f8 94       	cli

00000bd8 <__stop_program>:
 bd8:	ff cf       	rjmp	.-2      	; 0xbd8 <__stop_program>
